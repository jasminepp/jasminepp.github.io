<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Tag: Java - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/jasminepp.github.io/images/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":{"text":"Tianhao'Site"}}},"description":""}</script><link rel="icon" href="/jasminepp.github.io/images/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Tianhao&#039;Site</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">Java</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-09-14T23:00:00.000Z" title="15/09/2022, 00:00:00">2022-09-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-07-13T21:00:35.337Z" title="13/07/2023, 22:00:35">2023-07-13</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">3 minutes read (About 471 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/09/15/Combinations-Pruning/">Combinations-Pruning</a></h1><div class="content"><h2 id="Pruning-optimization"><a href="#Pruning-optimization" class="headerlink" title="Pruning optimization"></a>Pruning optimization</h2><p> There is the following code in the traversal process:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) &#123;</span><br><span class="line">    path.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The range of this traversal can be pruned and optimised, how?</p></div><a class="article-more button is-small is-size-7" href="/2022/09/15/Combinations-Pruning/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-07-30T23:00:00.000Z" title="31/07/2022, 00:00:00">2022-07-31</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-07-13T21:01:26.873Z" title="13/07/2023, 22:01:26">2023-07-13</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">6 minutes read (About 832 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/31/ConvertSortedArraytoBinarySearchTree/">Convert Sorted Array to Binary Search Tree</a></h1><div class="content"><h3 id="TEST-YOURSELF"><a href="#TEST-YOURSELF" class="headerlink" title="TEST YOURSELF"></a>TEST YOURSELF</h3><p>Given an integer array <em><strong>nums</strong></em> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a height-balanced binary search tree</em>.</p>
<p>A <strong>height-balanced</strong> binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p>
<p><strong>Example 1:</strong></p>
<p><img src="/.com//convert1.jpg" alt="Example 1"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><a class="article-more button is-small is-size-7" href="/2022/07/31/ConvertSortedArraytoBinarySearchTree/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-07-14T23:00:00.000Z" title="15/07/2022, 00:00:00">2022-07-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-07-13T21:03:00.832Z" title="13/07/2023, 22:03:00">2023-07-13</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">5 minutes read (About 715 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/15/InsertintoaBinarySearchTree/">Insert into a Binary Search Tree</a></h1><div class="content"><h3 id="TEST-YOURSELF"><a href="#TEST-YOURSELF" class="headerlink" title="TEST YOURSELF"></a>TEST YOURSELF</h3><p>You are given the <em><strong>root</strong></em> node of a binary search tree (BST) and a value to insert into the tree. Return the <em>root node of the BST after the insertion</em>. It is <strong>guaranteed</strong> that the new value does not exist in the original BST.</p>
<p>Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.</p>
<p><strong>Example 1:</strong></p>
<p><img src="/.com//insert1.jpg" alt="Example 1"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,2,7,1,3], val = 5</span><br><span class="line">Output: [4,2,7,1,3,5]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Explanation: Another accepted tree is:</p>
<p><img src="/.com//insert2.jpg" alt="Accepted tree"></p>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>We just need to follow the rules of the binary search tree to traverse and insert nodes when we encounter empty nodes.</p>
<p>For example, insert element 10, we need to find the last node to insert it, the same reasoning to insert element 15, insert element 0, insert element 6. </p>
<p><img src="/.com//insert3.jpg" alt="Insert 10"></p>
<p><img src="/.com//insert4.jpg" alt="Insert 15"></p>
<p><img src="/.com//insert5.jpg" alt="Insert 0"></p>
<p><img src="/.com//insert6.jpg" alt="Insert 6"></p>
<p>The next step is the process of traversing the binary search tree:</p>
<h3 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h3><ol>
<li><strong>Determine the parameters and return value of the recursive function:</strong></li>
</ol>
<p> The parameters are the root node pointer, and the element to be inserted.<br>We can use the return value to complete the assignment of the newly added node to its parent node<br>The return type of the recursive function is the node type <strong>TreeNode</strong>*</p>
   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>Determine the termination condition:</strong><br>The termination condition is to find the position of the node to be inserted when the traversed node is <strong>null</strong>, and to return the inserted node</li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>The logic for determining the single-level recursion:</strong></li>
</ol>
<p> We do not need to traverse the whole search tree.<br>Because the search tree is directed, the direction of recursion can be determined by the value of the inserted elements.</p>
   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>&amp;C++</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h3><p><strong>&amp;C++</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* parent = root; <span class="comment">//  we need to record last node, otherise we cannot give value to new node</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val &gt; val) cur = cur-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (val &lt; parent-&gt;val) parent-&gt;left = node;<span class="comment">//  Use parent node to give value</span></span><br><span class="line">        <span class="keyword">else</span> parent-&gt;right = node;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="amp-Java"><a href="#amp-Java" class="headerlink" title="&amp;Java"></a>&amp;Java</h3><p><strong>Recursion</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        TreeNode newRoot = root;</span><br><span class="line">        TreeNode pre = root;</span><br><span class="line">        <span class="keyword">while</span> (root != null) &#123;</span><br><span class="line">            pre = root;</span><br><span class="line">            <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre.val &gt; val) &#123;</span><br><span class="line">            pre.left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre.right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Iteration</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) <span class="comment">// if this node is empty, which means val finds the suitable position, return new node</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; val)&#123;</span><br><span class="line">            root.right = <span class="built_in">insertIntoBST</span>(root.right, val); <span class="comment">// create right subtree</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; val)&#123;</span><br><span class="line">            root.left = <span class="built_in">insertIntoBST</span>(root.left, val); <span class="comment">// create left subtree</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="amp-Python"><a href="#amp-Python" class="headerlink" title="&amp;Python"></a>&amp;Python</h3><p><strong>Recursion</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"><span class="meta"># class TreeNode:</span></span><br><span class="line"><span class="meta">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="meta">#         self.val = val</span></span><br><span class="line"><span class="meta">#         self.left = left</span></span><br><span class="line"><span class="meta">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="function">def <span class="title">insertIntoBST</span><span class="params">(self, root: TreeNode, val: <span class="type">int</span>)</span> -&gt; TreeNode:</span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        # Base Case</span></span><br><span class="line"><span class="function">        if not root: return TreeNode(val)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        if val &lt; root.val: </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">            root.left =</span> self.<span class="built_in">insertIntoBST</span>(root.left, val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">   </span><br><span class="line">            root.right = self.<span class="built_in">insertIntoBST</span>(root.right, val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p><strong>Iteration</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="function">def <span class="title">insertIntoBST</span><span class="params">(self, root: TreeNode, val: <span class="type">int</span>)</span> -&gt; TreeNode:</span></span><br><span class="line"><span class="function">        if not root: </span></span><br><span class="line"><span class="function">            return TreeNode(val)</span></span><br><span class="line"><span class="function">        parent =</span> None</span><br><span class="line">        cur = root</span><br><span class="line"></span><br><span class="line">        <span class="meta">#use while loop to find the parent of new node </span></span><br><span class="line">        <span class="keyword">while</span> cur: </span><br><span class="line">            <span class="keyword">if</span> cur.val &lt; val: </span><br><span class="line">                parent = cur</span><br><span class="line">                cur = cur.right</span><br><span class="line">            elif cur.val &gt; val: </span><br><span class="line">                parent = cur</span><br><span class="line">                cur = cur.left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta"># the parent of new node has been found</span></span><br><span class="line">        <span class="keyword">if</span> parent.val &gt; val: </span><br><span class="line">            parent.left = <span class="built_in">TreeNode</span>(val)</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            parent.right = <span class="built_in">TreeNode</span>(val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-06-29T23:00:00.000Z" title="30/06/2022, 00:00:00">2022-06-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-05T22:22:53.460Z" title="05/10/2022, 23:22:53">2022-10-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">6 minutes read (About 919 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/06/30/MergeTwoBinaryTrees/">Merge Two Binary Trees</a></h1><div class="content"><h3 id="TEST-YOURSELF"><a href="#TEST-YOURSELF" class="headerlink" title="TEST YOURSELF"></a>TEST YOURSELF</h3><p>You are given two binary trees <strong>root1</strong> and <strong>root2</strong>.</p>
<p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p>
<p>Return the <strong>merged tree</strong>.</p>
<p>Note: The merging process must start from the root nodes of both trees.</p>
<p>Example 1:</p>
<p><img src="/2022/06/30/MergeTwoBinaryTrees/merge1.jpg" alt="Example 1"></p>
<pre><code class="cpp、">Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
Output: [3,4,5,5,4,null,7]
</code></pre>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>It’s actually the <strong>same</strong> logic as traversing a tree, except that the nodes of both trees are passed in and operated on <strong>simultaneously</strong>.</p>
<h3 id="Resursion"><a href="#Resursion" class="headerlink" title="Resursion"></a>Resursion</h3><p>Use pre-order as an example:</p>
<p><img src="/2022/06/30/MergeTwoBinaryTrees/merge2.jpg" alt="Merge trees by Pre-order Traversal1"></p>
<p><img src="/2022/06/30/MergeTwoBinaryTrees/merge3.jpg" alt="Merge trees by Pre-order Traversal2"></p>
<p><img src="/2022/06/30/MergeTwoBinaryTrees/merge4.jpg" alt="Merge trees by Pre-order Traversal3"></p>
<ol>
<li><strong>Determine the parameters and return value of the recursive function:</strong> To merge two binary trees, then the argument is <em><strong>passed at least the root node of both binary trees</strong></em>, and the return value is the root node of the merged binary tree.</li>
</ol>
<pre><code class="cpp">TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123;
</code></pre>
<ol start="2">
<li><strong>Determine the termination condition:</strong> Since two trees are passed in, there will be two trees traversing nodes t1 and t2.</li>
</ol>
<p>  If t1 &#x3D;&#x3D; NULL, the two trees will be merged into t2 (it doesn’t matter if t2 is also NULL, it will be NULL after the merge).</p>
<p> If t2 &#x3D;&#x3D; NULL, then the two numbers are merged into t1 (it doesn’t matter if t1 is also NULL, the merge is NULL).</p>
<pre><code class="cpp">if (t1 == NULL) return t2; 
if (t2 == NULL) return t1; 
</code></pre>
<ol start="3">
<li><strong>The logic for determining the single-level recursion</strong>:<br> Adding the elements of two trees together</li>
</ol>
<pre><code class="cpp">t1-&gt;val += t2-&gt;val;
</code></pre>
<p>The l<strong>eft subtree of t1</strong> is: the left subtree after merging the left subtree of t1 and the left subtree of t2.</p>
<p>The <strong>right subtree of t1</strong> is: the right subtree after merging the right subtree of t1 and the right subtree of t2.</p>
<p>The <strong>final t1</strong> is the <em><strong>root</strong></em> node after the merge.</p>
<pre><code class="cpp">t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);
t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);
return t1;
</code></pre>
<p><strong>&amp;C++</strong></p>
<p> Complete code</p>
<pre><code class="cpp"> class Solution &#123;
public:
  TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123;
      if (t1 == NULL) return t2;
      if (t2 == NULL) return t1;
      // re-define new node, don&#39;t modity structure of the 2 old tree
      TreeNode* root = new TreeNode(0);
      root-&gt;val = t1-&gt;val + t2-&gt;val;
      root-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);
      root-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);
      return root;
  &#125;
&#125;;
</code></pre>
<h3 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h3><p><strong>&amp;C++</strong></p>
<pre><code class="cpp">class Solution &#123;
public:
   TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123;
       if (t1 == NULL) return t2;
       if (t2 == NULL) return t1;
       queue&lt;TreeNode*&gt; que;
       que.push(t1);
       que.push(t2);
       while(!que.empty()) &#123;
           TreeNode* node1 = que.front(); que.pop();
           TreeNode* node2 = que.front(); que.pop();
           // add val
           node1-&gt;val += node2-&gt;val;

           // if thel left node of 2 trees are both not empty, enter queue
           if (node1-&gt;left != NULL &amp;&amp; node2-&gt;left != NULL) &#123;
               que.push(node1-&gt;left);
               que.push(node2-&gt;left);
           &#125;
           // if thel right node of 2 trees are both noe empty, enter queue
           if (node1-&gt;right != NULL &amp;&amp; node2-&gt;right != NULL) &#123;
               que.push(node1-&gt;right);
               que.push(node2-&gt;right);
           &#125;

               //  when left node of t1=null, t2 !=null, set val
           if (node1-&gt;left == NULL &amp;&amp; node2-&gt;left != NULL) &#123;
               node1-&gt;left = node2-&gt;left;
           &#125;
           // when right node of t1=null, t2 !=null, set val
           if (node1-&gt;right == NULL &amp;&amp; node2-&gt;right != NULL) &#123;
               node1-&gt;right = node2-&gt;right;
           &#125;
       &#125;
       return t1;
   &#125;
&#125;;
</code></pre>
<p><strong>&amp;Java</strong></p>
<p><strong>Recursion</strong></p>
<pre><code class="cpp">class Solution &#123;
  public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;
      if (root1 == null) return root2;
      if (root2 == null) return root1;

      root1.val += root2.val;
      root1.left = mergeTrees(root1.left,root2.left);
      root1.right = mergeTrees(root1.right,root2.right);
      return root1;
  &#125;
&#125;
</code></pre>
<p><strong>Iteration</strong></p>
<pre><code class="cpp"> class Solution &#123;
    // using queue
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;
        if (root1 == null) return root2;
        if (root2 ==null) return root1;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root1);
        queue.offer(root2);
        while (!queue.isEmpty()) &#123;
            TreeNode node1 = queue.poll();
            TreeNode node2 = queue.poll();
           
            node1.val = node1.val + node2.val;

            if (node1.left != null &amp;&amp; node2.left != null) &#123;
                queue.offer(node1.left);
                queue.offer(node2.left);
            &#125;
    
            if (node1.right != null &amp;&amp; node2.right != null) &#123;
                queue.offer(node1.right);
                queue.offer(node2.right);
            &#125;

            if (node1.left == null &amp;&amp; node2.left != null) &#123;
                node1.left = node2.left;
            &#125;

            if (node1.right == null &amp;&amp; node2.right != null) &#123;
                node1.right = node2.right;
            &#125;
        &#125;
        return root1;
    &#125;
&#125;
</code></pre>
<p><strong>&amp;Python</strong></p>
<p><strong>Recursion</strong></p>
<pre><code class="cpp"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -&gt; TreeNode:
       
        if not root1: 
            return root2
        if not root2: 
            return root1
        
        root1.val += root2.val # 中
        root1.left = self.mergeTrees(root1.left, root2.left) #left
        root1.right = self.mergeTrees(root1.right, root2.right) # right
        
        return root1
</code></pre>
<p><strong>Iteration</strong></p>
<pre><code class="cpp">class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -&gt; TreeNode:
        if not root1: 
            return root2
        if not root2: 
            return root1

        queue = deque()
        queue.append(root1)
        queue.append(root2)

        while queue: 
            node1 = queue.popleft()
            node2 = queue.popleft()
            # update queue

            if node1.left and node2.left: 
                queue.append(node1.left)
                queue.append(node2.left)

            if node1.right and node2.right: 
                queue.append(node1.right)
                queue.append(node2.right)


            node1.val += node2.val
            if not node1.left and node2.left: 
                node1.left = node2.left
            if not node1.right and node2.right: 
                node1.right = node2.right

        return root1
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-06-13T23:00:00.000Z" title="14/06/2022, 00:00:00">2022-06-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-05T22:22:54.653Z" title="05/10/2022, 23:22:54">2022-10-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">5 minutes read (About 712 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/06/14/MinimumDepthofBinaryTree/">Minimum Depth of Binary Tree</a></h1><div class="content"><h3 id="TEST-YOURSELF"><a href="#TEST-YOURSELF" class="headerlink" title="TEST YOURSELF"></a>TEST YOURSELF</h3><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<p><strong>Example 1:</strong></p>
<p><img src="/2022/06/14/MinimumDepthofBinaryTree/min1.jpg" alt="Example1"></p>
<pre><code class="cpp">Input: root = [3,9,20,null,null,15,7]
Output: 2
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code class="cpp">Input: root = [2,null,3,null,4,null,5,null,6]
Output: 5
</code></pre>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>Intuitively, it seems to be similar to finding the maximum depth, but in fact it is still quite <strong>different</strong>.</p>
<p>In the following explanation, we still use <strong>post-order</strong><br>traversal in the order of traversal (because we want to compare the results after the recursive returns)</p>
<p>We first need to understand the definition of <strong>minimum depth</strong>: the minimum depth is the number of nodes on the shortest path from the root node to the <strong>nearest leaf node</strong></p>
<p><img src="/2022/06/14/MinimumDepthofBinaryTree/min2.jpg" alt="minDepth is 3"></p>
<h3 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h3><ol>
<li><strong>Determine the parameters and return value of the recursive function:</strong> The parameter is the root node of the binary tree to be passed in, and the depth returned is of type <em><strong>int</strong></em>.</li>
</ol>
<pre><code class="cpp">int getDepth(TreeNode* node)
</code></pre>
<ol start="2">
<li><strong>Determine the termination condition:</strong> if the node is empty, 0 is returned, indicating a height of 0.</li>
</ol>
<pre><code class="cpp">if (node == NULL) return 0;
</code></pre>
<ol start="3">
<li><strong>The logic for determining the single-level recursion</strong>:</li>
</ol>
<ul>
<li><p>If the left subtree is empty and the right subtree is not empty, then the minimum depth is: <strong>1 + the depth of the right subtree</strong>.</p>
</li>
<li><p>Conversely, if the right subtree is empty and the left subtree is not empty, the minimum depth is: <strong>1 + the depth of the left subtree</strong>. </p>
</li>
<li><p>Finally, if neither the left nor the right subtree is empty, return <strong>the minimum depth of the left or right subtree+1</strong>.</p>
</li>
</ul>
<pre><code class="cpp">// it is not the most deep node when the left subtree is empty and the right subtree is not empty
if (node-&gt;left == NULL &amp;&amp; node-&gt;right != NULL) &#123; 
   return 1 + rightDepth;
&#125;   
// it is not the most deep node when the left subtree is not empty and the right subtree is empty
if (node-&gt;left != NULL &amp;&amp; node-&gt;right == NULL) &#123; 
   return 1 + leftDepth;
&#125;
int result = 1 + min(leftDepth, rightDepth);
return result;
</code></pre>
<p><strong>&amp;C++</strong></p>
<pre><code class="cpp">class Solution &#123;
public:
    int minDepth(TreeNode* root) &#123;
        if (root == NULL) return 0;
        if (root-&gt;left == NULL &amp;&amp; root-&gt;right != NULL) &#123;
            return 1 + minDepth(root-&gt;right);
        &#125;
        if (root-&gt;left != NULL &amp;&amp; root-&gt;right == NULL) &#123;
            return 1 + minDepth(root-&gt;left);
        &#125;
        return 1 + min(minDepth(root-&gt;left), minDepth(root-&gt;right));
    &#125;
&#125;;
</code></pre>
<h3 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h3><p>   <strong>&amp;C++</strong></p>
<pre><code class="cpp">class Solution &#123;
public:

    int minDepth(TreeNode* root) &#123;
        if (root == NULL) return 0;
        int depth = 0;
        queue&lt;TreeNode*&gt; que;
        que.push(root);
        while(!que.empty()) &#123;
            int size = que.size();
            depth++; // reord
            for (int i = 0; i &lt; size; i++) &#123;
                TreeNode* node = que.front();
                que.pop();
                if (node-&gt;left) que.push(node-&gt;left);
                if (node-&gt;right) que.push(node-&gt;right);
                if (!node-&gt;left &amp;&amp; !node-&gt;right) &#123;                     return depth;
                &#125;
            &#125;
        &#125;
        return depth;
    &#125;
&#125;;
</code></pre>
<p>   <strong>&amp;Java</strong></p>
<ul>
<li><strong>Resursion</strong></li>
</ul>
<pre><code class="cpp">class Solution &#123;
   
    public int minDepth(TreeNode root) &#123;
        if (root == null) &#123;
            return 0;
        &#125;
        int leftDepth = minDepth(root.left);
        int rightDepth = minDepth(root.right);
        if (root.left == null) &#123;
            return rightDepth + 1;
        &#125;
        if (root.right == null) &#123;
            return leftDepth + 1;
        &#125;
        // both left node and right node are not empty 
        return Math.min(leftDepth, rightDepth) + 1;
    &#125;
&#125;

</code></pre>
<ul>
<li><strong>Iteration</strong></li>
</ul>
<pre><code class="cpp">class Solution &#123;

    public int minDepth(TreeNode root) &#123;
        if (root == null) &#123;
            return 0;
        &#125;
        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();
        deque.offer(root);
        int depth = 0;
        while (!deque.isEmpty()) &#123;
            int size = deque.size();
            depth++;
            for (int i = 0; i &lt; size; i++) &#123;
                TreeNode poll = deque.poll();
                if (poll.left == null &amp;&amp; poll.right == null) &#123;
#                     // when iterate leaf node ,return directly. since it is level oreder traversal, this value is minimum
                    return depth;
                &#125;
                if (poll.left != null) &#123;
                    deque.offer(poll.left);
                &#125;
                if (poll.right != null) &#123;
                    deque.offer(poll.right);
                &#125;
            &#125;
        &#125;
        return depth;
    &#125;
&#125;
</code></pre>
<p>   <strong>&amp;Python</strong></p>
<ul>
<li><strong>Resursion</strong></li>
</ul>
<pre><code class="cpp">class Solution:
    def minDepth(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        if not root.left and not root.right:
            return 1

        min_depth = 10**9
        if root.left:
#             min_depth = min(self.minDepth(root.left), min_depth) # the minimum depth of left subtree
        if root.right:
            min_depth = min(self.minDepth(root.right), min_depth) # the minimum depth of right subtree
        return min_depth + 1
</code></pre>
<ul>
<li><strong>Iteration</strong></li>
</ul>
<pre><code class="cpp">class Solution:
    def minDepth(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        if not root.left and not root.right:
            return 1

        min_depth = 10**9
        if root.left:
            min_depth = min(self.minDepth(root.left), min_depth) # the minimum depth of left subtree
        if root.right:
            min_depth = min(self.minDepth(root.right), min_depth) # the minimum depth of right subtree
        return min_depth + 1
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-30T23:00:00.000Z" title="31/05/2022, 00:00:00">2022-05-31</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-05T22:22:52.987Z" title="05/10/2022, 23:22:52">2022-10-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">4 minutes read (About 666 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/31/MaximumDepthofBinaryTree/">Maximum Depth of Binary Tree</a></h1><div class="content"><h3 id="TEST-YOURSELF"><a href="#TEST-YOURSELF" class="headerlink" title="TEST YOURSELF"></a>TEST YOURSELF</h3><p>Given the <strong>root</strong> of a binary tree, return its maximum depth.</p>
<p>A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p>Example1:</p>
<p><img src="/2022/05/31/MaximumDepthofBinaryTree/maxeg1.jpg" alt="Example1"></p>
<pre><code class="cpp">Input: root = [3,9,20,null,null,15,7]
Output: 3
</code></pre>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><h3 id="Resursion"><a href="#Resursion" class="headerlink" title="Resursion"></a>Resursion</h3><p>The problem can be solved using either <strong>preorder</strong> (parent left and right) or <strong>postorder</strong> traversal (left and right parent), using preorder to find the <strong>depth</strong> and postorder to find the <strong>height</strong>.</p>
<ul>
<li><strong>The depth of a binary tree node:</strong> the number of edges or nodes of the longest simple path from the root node to that node (depending on whether the depth starts at 0 or 1)</li>
<li><strong>The height of a binary tree node:</strong> the number of edges of the longest simple path from that node to the leaf node (depending on whether the height starts at 0 or 1)</li>
</ul>
<p>The height of the root node is the maximum depth of the binary tree, so in this problem we find the maximum depth of the binary tree by the height of the root node in the post-order.</p>
<p>we start with a post-order traversal (left and right middle) to calculate the height of the tree.</p>
<ol>
<li><strong>Determine the parameters and return value of the recursive function:</strong> the parameter is the root node of the incoming tree, and the return returns the depth of the tree, so the return value is of type int.<br>The code is as follows.</li>
</ol>
<pre><code class="cpp">int getdepth(treenode* node)
</code></pre>
<ol start="2">
<li><strong>Determine the termination condition:</strong> if the node is empty, 0 is returned, indicating a height of 0.</li>
</ol>
<pre><code class="cpp">if (node == NULL) return 0;
</code></pre>
<ol start="3">
<li><strong>The logic for determining the single-level recursion</strong>: <em><strong>first</strong></em> find the depth of its left subtree, <em><strong>then</strong></em> the depth of its right subtree, and <em><strong>finally</strong></em> take the largest value of the left and right depths and add 1 (plus 1 because the current middle node is included) to the depth of the tree whose current node is the root node.</li>
</ol>
<pre><code class="cpp">int leftdepth = getdepth(node-&gt;left);       // left
int rightdepth = getdepth(node-&gt;right);     // right
int depth = 1 + max(leftdepth, rightdepth); // parent
return depth;
</code></pre>
<p><strong>&amp;C++</strong></p>
<pre><code class="cpp">class solution &#123;
public:
    int getdepth(treenode* node) &#123;
        if (node == NULL) return 0;
        int leftdepth = getdepth(node-&gt;left);       // left
        int rightdepth = getdepth(node-&gt;right);     // right
        int depth = 1 + max(leftdepth, rightdepth); // parent
        return depth;
    &#125;
    int maxdepth(treenode* root) &#123;
        return getdepth(root);
    &#125;
&#125;;
</code></pre>
<h3 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h3><p>Using the iterative method, it is most appropriate to use a <strong>level orde</strong>r traversal, because the **maximum depth **is the <em><strong>number of layers</strong></em> in the binary tree, which fits perfectly with the level order traversal.</p>
<p>As shown in the figure:</p>
<p><img src="/2022/05/31/MaximumDepthofBinaryTree/max1.jpg" alt="Max_depth By level order traversal"></p>
<h3 id="amp-C"><a href="#amp-C" class="headerlink" title="&amp;C++"></a>&amp;C++</h3><pre><code class="cpp">class solution &#123;
public:
    int maxdepth(treenode* root) &#123;
        if (root == NULL) return 0;
        int depth = 0;
        queue&lt;treenode*&gt; que;
        que.push(root);
        while(!que.empty()) &#123;
            int size = que.size();
            depth++; // record depth
            for (int i = 0; i &lt; size; i++) &#123;
                treenode* node = que.front();
                que.pop();
                if (node-&gt;left) que.push(node-&gt;left);
                if (node-&gt;right) que.push(node-&gt;right);
            &#125;
        &#125;
        return depth;
    &#125;
&#125;;
</code></pre>
<p><strong>&amp;Java</strong></p>
<pre><code class="cpp">class solution &#123;
    /**
     * Resursion
     */
    public int maxDepth(TreeNode root) &#123;
        if (root == null) &#123;
            return 0;
        &#125;
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        return Math.max(leftDepth, rightDepth) + 1;
    &#125;
&#125;
</code></pre>
<pre><code class="cpp">class solution &#123;
    /**
     * Iteration by level order traversal
     */
    public int maxDepth(TreeNode root) &#123;
        if(root == null) &#123;
            return 0;
        &#125;
        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();
        deque.offer(root);
        int depth = 0;
        while (!deque.isEmpty()) &#123;
            int size = deque.size();
            depth++;
            for (int i = 0; i &lt; size; i++) &#123;
                TreeNode node = deque.poll();
                if (node.left != null) &#123;
                    deque.offer(node.left);
                &#125;
                if (node.right != null) &#123;
                    deque.offer(node.right);
                &#125;
            &#125;
        &#125;
        return depth;
    &#125;
&#125;
</code></pre>
<h3 id="amp-Python"><a href="#amp-Python" class="headerlink" title="&amp;Python"></a>&amp;Python</h3><p><strong>Resursion</strong></p>
<pre><code class="cpp">class solution:
    def maxdepth(self, root: treenode) -&gt; int:
        if not root:
            return 0
        return 1 + max(self.maxdepth(root.left), self.maxdepth(root.right))
</code></pre>
<p><strong>Iteration</strong></p>
<pre><code class="cpp">import collections
class solution:
    def maxdepth(self, root: treenode) -&gt; int:
        if not root:
            return 0
        depth = 0 #record depth
        queue = collections.deque()
        queue.append(root)
        while queue:
            size = len(queue)
            depth += 1
            for i in range(size):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return depth
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-29T23:00:00.000Z" title="30/04/2022, 00:00:00">2022-04-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-07-13T21:04:49.089Z" title="13/07/2023, 22:04:49">2023-07-13</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">3 minutes read (About 407 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/LevelOrderTraversalofBinaryTree/">Level Order Traversal of Binary Tree</a></h1><div class="content"><p>Given the <strong>root</strong> of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level).</p>
<p><strong>Example1:</strong></p>
<p><img src="/.com//eg1.jpg" alt="Example1"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">Output: [[<span class="number">3</span>],[<span class="number">9</span>,<span class="number">20</span>],[<span class="number">15</span>,<span class="number">7</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Example2:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>]</span><br><span class="line">Output: [[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>Level order Traversal:<br> This means traversing the binary tree one layer at a time from left to right.<br>This is achieved by borrowing an auxiliary data structure: the queue, which is FIFO(first-in-first-out), in line with the logic of layer-by-layer traversal.</p>
<p>This level order traversal is the breadth-first traversal in graph theory, except that we apply it to binary trees.</p>
<p>A breadth-first traversal of a binary tree using a queue is as follows.</p>
<p><img src="/.com//fifo1.jpg" alt="FIFO_1"></p>
<p><img src="/.com//fifo2.jpg" alt="FIFO_2"></p>
<p><img src="/.com//fifo3.jpg" alt="FIFO_3"></p>
<p><img src="/.com//fifo4.jpg" alt="FIFO_4"></p>
<h3 id="amp-C"><a href="#amp-C" class="headerlink" title="&amp;C++"></a>&amp;C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// fixed siize(since que.size is changing)            for (int i = 0; i &lt; size; i++) &#123;</span></span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Iteration</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">order</span><span class="params">(TreeNode* cur, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() == depth) result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        result[depth].<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;left, result, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;right, result, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">order</span>(root, result, depth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="amp-Java"><a href="#amp-Java" class="headerlink" title="&amp;Java"></a>&amp;Java</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//checkFun01(root,0);</span></span><br><span class="line">        <span class="built_in">checkFun02</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DFS--Resursion</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">checkFun01</span><span class="params">(TreeNode node, Integer deep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == null) <span class="keyword">return</span>;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resList.<span class="built_in">size</span>() &lt; deep) &#123;</span><br><span class="line">            <span class="comment">//when number of level is larger,the item of list is larger. we use the index of list to distinguish diffrent levels</span></span><br><span class="line">            List&lt;Integer&gt; item = <span class="keyword">new</span> <span class="built_in">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            resList.<span class="built_in">add</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">        resList.<span class="built_in">get</span>(deep - <span class="number">1</span>).<span class="built_in">add</span>(node.val);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">checkFun01</span>(node.left, deep);</span><br><span class="line">        <span class="built_in">checkFun01</span>(node.right, deep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BFS--Iteration--use queue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">checkFun02</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == null) <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="built_in">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        que.<span class="built_in">offer</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            List&lt;Integer&gt; itemList = <span class="keyword">new</span> <span class="built_in">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> len = que.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode tmpNode = que.<span class="built_in">poll</span>();</span><br><span class="line">                itemList.<span class="built_in">add</span>(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tmpNode.left != null) que.<span class="built_in">offer</span>(tmpNode.left);</span><br><span class="line">                <span class="keyword">if</span> (tmpNode.right != null) que.<span class="built_in">offer</span>(tmpNode.right);</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resList.<span class="built_in">add</span>(itemList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-11T23:00:00.000Z" title="12/04/2022, 00:00:00">2022-04-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-05T23:22:44.000Z" title="06/10/2022, 00:22:44">2022-10-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">5 minutes read (About 708 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/12/RecursiveTraversalofBinaryTree/">Recursive Traversal of Binary Tree</a></h1><div class="content"><p><strong>Three elements</strong> of the <em><strong>recursive</strong></em> algorithm：</p>
<ol>
<li><p><strong>Determine the parameters and return value of the recursive function:</strong> Determine which parameters need to be handled during the recursion process, then add this parameter to the recursive function, and also define what the return value of each recursion is and thus determine the return type of the recursive function.</p>
</li>
<li><p><strong>Determine the termination conditions:</strong> After writing a recursive algorithm, when running it, we will often encounter a stack overflow error, that is, we have not written the termination conditions or the termination conditions are not written correctly.</p>
</li>
<li><p><strong>The logic for determining a single level of recursion:</strong> Determine the information that needs to be processed at each level of recursion. Here too, the call itself is repeated to implement the recursion process.</p>
</li>
</ol>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><p>The following is an example of a <strong>preorder traversal</strong>.</p>
<ol>
<li><strong>Determine the parameters of the recursive function and return value:</strong> because to print out the value of the node of the preorder traversal, so the parameters need to be passed in the vector in the value of the node put, in addition to this point will not need to deal with what data is also not required to have a return value, so the recursive function return type is void:</li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>Determine the termination conditions:</strong> in the process of recursion, how is the recursion is considered to end it, of course, the current traversal of the node is empty, then this layer of recursion is going to end, so if the current traversal of this node is empty, it is a direct return:</li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>Determine the logic of the single-level recursion:</strong> preorder traversal is the <strong>middle-left-right</strong> order, so the logic in the single-level recursion, is to first take the value of the node:</li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// in</span></span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">//left</span></span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// right</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Pre-Order</strong>: (Visit the parent node first, then the left and right nodes in turn)</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// parent</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// left</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// right</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>In-Order</strong>：(Visit the left node first, then the parent and right nodes in turn)</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// left</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// parent</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>Post-Order</strong>：(Visit the left node first, then the right and parent nodes in turn)</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// left</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// right</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// parent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="amp-Java"><a href="#amp-Java" class="headerlink" title="&amp;Java"></a>&amp;Java</h3> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pre-Order-Recursion</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="built_in">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="built_in">preorder</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">add</span>(root.val);</span><br><span class="line">        <span class="built_in">preorder</span>(root.left, result);</span><br><span class="line">        <span class="built_in">preorder</span>(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// In-Order-Recursion</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="built_in">inorder</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inorder</span>(root.left, list);</span><br><span class="line">        list.<span class="built_in">add</span>(root.val);             <span class="comment">// </span></span><br><span class="line">        <span class="built_in">inorder</span>(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Post-Order-Recursion</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="built_in">postorder</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">postorder</span>(root.left, list);</span><br><span class="line">        <span class="built_in">postorder</span>(root.right, list);</span><br><span class="line">        list.<span class="built_in">add</span>(root.val);             <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="amp-Python"><a href="#amp-Python" class="headerlink" title="&amp;Python"></a>&amp;Python</h3> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"># Pre-Order-Recursion</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="function">def <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[<span class="type">int</span>]:</span></span><br><span class="line"><span class="function">        # save result</span></span><br><span class="line"><span class="function">        result =</span> []</span><br><span class="line">        </span><br><span class="line">        <span class="function">def <span class="title">traversal</span><span class="params">(root: TreeNode)</span>:</span></span><br><span class="line"><span class="function">            if root =</span>= None:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            result.<span class="built_in">append</span>(root.val) <span class="meta"># parent</span></span><br><span class="line">            <span class="built_in">traversal</span>(root.left)    <span class="meta"># left</span></span><br><span class="line">            <span class="built_in">traversal</span>(root.right)   <span class="meta"># right</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"># In-Order-Recursion</span><br><span class="line"><span class="keyword">class</span> Solution:</span><br><span class="line">    def <span class="built_in">inorderTraversal</span>(self, root: TreeNode) -&gt; List[<span class="type">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        def <span class="built_in">traversal</span>(root: TreeNode):</span><br><span class="line">            <span class="keyword">if</span> root == None:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="built_in">traversal</span>(root.left)    <span class="meta"># left</span></span><br><span class="line">            result.<span class="built_in">append</span>(root.val) <span class="meta"># parent</span></span><br><span class="line">            <span class="built_in">traversal</span>(root.right)   <span class="meta"># right</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"># Post-Order-Recursion</span><br><span class="line"><span class="keyword">class</span> Solution:</span><br><span class="line">    def <span class="built_in">postorderTraversal</span>(self, root: TreeNode) -&gt; List[<span class="type">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        def <span class="built_in">traversal</span>(root: TreeNode):</span><br><span class="line">            <span class="keyword">if</span> root == None:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="built_in">traversal</span>(root.left)    <span class="meta"># left</span></span><br><span class="line">            <span class="built_in">traversal</span>(root.right)   <span class="meta"># right</span></span><br><span class="line">            result.<span class="built_in">append</span>(root.val) <span class="meta"># parent</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">traversal</span>(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-27T23:00:00.000Z" title="28/03/2022, 00:00:00">2022-03-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-07-13T21:00:08.577Z" title="13/07/2023, 22:00:08">2023-07-13</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">4 minutes read (About 534 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/03/28/BinaryTreeBasic/">Binary Tree Basic</a></h1><div class="content"><h3 id="What-is-Binary-Tree-Data-Structure"><a href="#What-is-Binary-Tree-Data-Structure" class="headerlink" title="What is Binary Tree Data Structure?"></a>What is Binary Tree Data Structure?</h3><p><strong>Binary Tree</strong> is defined as a Tree data structure with at most 2 children. Since each element in a binary tree can have only 2 children, we typically name them the left and right child.</p>
<h2 id="The-Type-of-Binary-Trees"><a href="#The-Type-of-Binary-Trees" class="headerlink" title="The Type of Binary Trees"></a>The Type of Binary Trees</h2><h3 id="1-Full-Binary-Tree"><a href="#1-Full-Binary-Tree" class="headerlink" title="1. Full Binary Tree"></a>1. Full Binary Tree</h3><p>  <strong>k-ary tree</strong>:  A (rooted) tree is k-ary if every node has at most k children. If k &#x3D; 2 then the tree is called binary.<br>  A k ary tree is <strong>full</strong> if every internal node has exactly k children</p>
<p> <img src="/.com//full.jpg" alt="Full 3-ary Tree"></p>
<h3 id="2-Complete-Binary-Tree"><a href="#2-Complete-Binary-Tree" class="headerlink" title="2. Complete Binary Tree"></a>2. Complete Binary Tree</h3><p>  <strong>complete</strong> if all levels except possibly the last is entirely filled (and last level is filled from left to right)</p>
<p>  <img src="/.com//complete.jpg" alt="Complete 3-ary Tree"></p>
<h3 id="3-Binary-Search-Tree"><a href="#3-Binary-Search-Tree" class="headerlink" title="3. Binary Search Tree"></a>3. Binary Search Tree</h3><p>The trees described earlier have no values, while a binary search tree <strong>has values</strong>. A binary search tree is an <em><strong>ordered tree</strong></em>.</p>
<ul>
<li>if its left subtree is not empty, the values of all nodes in the left subtree are less than the value of its root node.</li>
<li>if its right subtree is not empty, the values of all nodes in the right subtree are greater than the value of its root node.</li>
</ul>
<p>Its left and right subtrees are also each binary sorted trees</p>
<p>The following two trees are both search trees:<br><img src="/.com//search.jpg" alt="Binary Search Tree"></p>
<h3 id="4-Balanced-Binary-Tree"><a href="#4-Balanced-Binary-Tree" class="headerlink" title="4. Balanced Binary Tree"></a>4. Balanced Binary Tree</h3><p>Balanced Binary Tree：also known as an AVL (Adelson-Velsky and Landis) tree and has the following properties: </p>
<ul>
<li>it is an empty tree <strong>or</strong></li>
<li>the difference in <strong>height</strong> between its left and right subtrees does not exceed <strong>1</strong>in absolute value </li>
<li>both left and right subtrees are a balanced binary tree.</li>
</ul>
<p>as shown：<br><img src="/.com//AVL.jpg" alt="Balanced Binary Tree"></p>
<p>The last one is not a balanced binary tree because the absolute value of the difference between the heights of its left and right subtrees exceeds 1.</p>
<h2 id="How-binary-trees-are-stored"><a href="#How-binary-trees-are-stored" class="headerlink" title="How binary trees are stored"></a>How binary trees are stored</h2><p>There are two types of storage for binary trees.</p>
<ul>
<li><strong>Linked storage</strong>(pointer)</li>
<li><strong>Sequential storage</strong>(array)</li>
</ul>
<p><em><strong>Sequential storage</strong></em> has a <em>continuous</em> distribution of elements in memory, whereas <em><strong>linked storage</strong></em> has a series of nodes distributed at scattered addresses by means of <strong>pointers</strong>.</p>
<p><img src="/.com//linked.jpg" alt="Linked storage"></p>
<p><img src="/.com//seq1.jpg" alt="Sequential storage"><br><img src="/.com//seq2.jpg" alt="Array Storage"></p>
<p><strong>How does using an array to store a binary tree traverse?</strong></p>
<p>If the parent node’s array subscript is i, then its left child is i * 2 + 1 and its right child is i * 2 + 2.</p>
<h2 id="Traversing-Binary-Tree"><a href="#Traversing-Binary-Tree" class="headerlink" title="Traversing Binary Tree"></a>Traversing Binary Tree</h2><p>There are <strong>two</strong> main types of traversal of a binary tree.</p>
<ol>
<li><em><strong>Depth-first traversal</strong></em>: go deeper first, then back when you encounter a leaf node.</li>
</ol>
<ul>
<li>Pre-order traversal (recursive, iterative )</li>
<li>In-order traversal (recursive, iterative)</li>
<li>Post-order traversal (recursive, iterative)</li>
</ul>
<ol start="2">
<li><em><strong>Breadth-first traversa</strong></em>l: go through layer by layer.<br> Level Order traversal (iterative)</li>
</ol>
<h2 id="The-Definition-of-Binary-Tree"><a href="#The-Definition-of-Binary-Tree" class="headerlink" title="The Definition of Binary Tree"></a>The Definition of Binary Tree</h2><h3 id="amp-C"><a href="#amp-C" class="headerlink" title="&amp;C++"></a>&amp;C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="amp-Java"><a href="#amp-Java" class="headerlink" title="&amp;Java"></a>&amp;Java</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">  	TreeNode left;</span><br><span class="line">  	TreeNode right;</span><br><span class="line">  	<span class="built_in">TreeNode</span>() &#123;&#125;</span><br><span class="line">  	<span class="built_in">TreeNode</span>(<span class="type">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">  	<span class="built_in">TreeNode</span>(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">    		<span class="keyword">this</span>.val = val;</span><br><span class="line">    		<span class="keyword">this</span>.left = left;</span><br><span class="line">    		<span class="keyword">this</span>.right = right;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="amp-Python"><a href="#amp-Python" class="headerlink" title="&amp;Python"></a>&amp;Python</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>: </span><br><span class="line">    def __init__(self, value):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = None</span><br><span class="line">        self.right = None</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-11T00:00:00.000Z" title="11/03/2022, 00:00:00">2022-03-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-03T11:51:42.758Z" title="03/10/2022, 12:51:42">2022-10-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">a few seconds read (About 66 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/03/11/RepeatedSubstringPattern(2)/">Repeated Substring Pattern(2)</a></h1><div class="content"><p>There is a problem with <strong><a target="_blank" rel="noopener" href="https://jasminepp.github.io/2022/02/28/RepeatedSubstringPattern(1)/">move matching</a></strong>:  we end up with the process of determining whether a string (<em><strong>s + s</strong></em>) has an occurrence of <em><strong>s</strong></em>. We could just use libraries like <em><strong>contains</strong></em>, <em><strong>find</strong></em> and so on. This ignores the time complexity of implementing these functions (the brute force solution is <strong>m * n</strong>, and the general library implementation is <strong>O(m + n))</strong></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/tags/Java/page/0/">Previous</a></div><div class="pagination-next"><a href="/tags/Java/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/tags/Java/">1</a></li><li><a class="pagination-link" href="/tags/Java/page/2/">2</a></li><li><a class="pagination-link" href="/tags/Java/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/categories/DeepLearning/"><span class="level-start"><span class="level-item">DeepLearning</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-14T23:00:00.000Z">2023-08-15</time></p><p class="title"><a href="/2023/08/15/Test/">TEST</a></p><p class="categories"><a href="/categories/DeepLearning/">DeepLearning</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-09-29T23:00:00.000Z">2022-09-30</time></p><p class="title"><a href="/2022/09/30/LetterCombinationsofaPhoneNumber/">Letter Combinations of a Phone Number</a></p><p class="categories"><a href="/categories/Algorithm/">Algorithm</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-09-14T23:00:00.000Z">2022-09-15</time></p><p class="title"><a href="/2022/09/15/Combinations-Pruning/">Combinations-Pruning</a></p><p class="categories"><a href="/categories/Algorithm/">Algorithm</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-08-14T23:00:00.000Z">2022-08-15</time></p><p class="title"><a href="/2022/08/15/BackTrackingAlgorithmBasic/">BackTracking Algorithm Basic</a></p><p class="categories"><a href="/categories/Algorithm/">Algorithm</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-30T23:00:00.000Z">2022-07-31</time></p><p class="title"><a href="/2022/07/31/ConvertSortedArraytoBinarySearchTree/">Convert Sorted Array to Binary Search Tree</a></p><p class="categories"><a href="/categories/Algorithm/">Algorithm</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Array/"><span class="tag">Array</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BackTracking/"><span class="tag">BackTracking</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BinarySearchTree/"><span class="tag">BinarySearchTree</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BinaryTree/"><span class="tag">BinaryTree</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-C/"><span class="tag">C/C++</span><span class="tag">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Combination/"><span class="tag">Combination</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DoublePointers/"><span class="tag">DoublePointers</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Iteration/"><span class="tag">Iteration</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LinkedList/"><span class="tag">LinkedList</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linkedlist/"><span class="tag">Linkedlist</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Optimazation/"><span class="tag">Optimazation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Pruning/"><span class="tag">Pruning</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Resursion/"><span class="tag">Resursion</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/String/"><span class="tag">String</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TraversalOfBinaryTree/"><span class="tag">TraversalOfBinaryTree</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/loop-invariant/"><span class="tag">loop invariant</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/jasminepp.github.io/images/avatar.jpg" alt="Tianhao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Tianhao</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Bristol,United Kingdom</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">24</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">18</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/jasminepp/jasminepp.github.io" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/jasminepp/jasminepp.github.io"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/08/"><span class="level-start"><span class="level-item">August 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/09/"><span class="level-start"><span class="level-item">September 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/08/"><span class="level-start"><span class="level-item">August 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">July 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">June 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">October 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Tianhao&#039;Site</a><p class="is-size-7"><span>&copy; 2023 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'folded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>