<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Tag: Iteration - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":{"text":"Tianhao'Site"}}},"description":""}</script><link rel="icon" href="/img/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="jasmine"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="jasmine"></script><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Tianhao&#039;Site</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">Iteration</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-07-30T23:00:00.000Z" title="31/07/2022, 00:00:00">2022-07-31</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">6 minutes read (About 832 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/31/ConvertSortedArraytoBinarySearchTree/">Convert Sorted Array to Binary Search Tree</a></h1><div class="content"><h3 id="TEST-YOURSELF"><a href="#TEST-YOURSELF" class="headerlink" title="TEST YOURSELF"></a>TEST YOURSELF</h3><p>Given an integer array <em><strong>nums</strong></em> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a height-balanced binary search tree</em>.</p>
<p>A <strong>height-balanced</strong> binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p>
<p><strong>Example 1:</strong></p>
<p><img src="/2022/07/31/ConvertSortedArraytoBinarySearchTree/convert1.jpg" alt="Example 1"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><a class="article-more button is-small is-size-7" href="/2022/07/31/ConvertSortedArraytoBinarySearchTree/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-07-14T23:00:00.000Z" title="15/07/2022, 00:00:00">2022-07-15</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">5 minutes read (About 715 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/07/15/InsertintoaBinarySearchTree/">Insert into a Binary Search Tree</a></h1><div class="content"><h3 id="TEST-YOURSELF"><a href="#TEST-YOURSELF" class="headerlink" title="TEST YOURSELF"></a>TEST YOURSELF</h3><p>You are given the <em><strong>root</strong></em> node of a binary search tree (BST) and a value to insert into the tree. Return the <em>root node of the BST after the insertion</em>. It is <strong>guaranteed</strong> that the new value does not exist in the original BST.</p>
<p>Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.</p>
<p><strong>Example 1:</strong></p>
<p><img src="/2022/07/15/InsertintoaBinarySearchTree/insert1.jpg" alt="Example 1"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,2,7,1,3], val = 5</span><br><span class="line">Output: [4,2,7,1,3,5]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Explanation: Another accepted tree is:</p>
<p><img src="/2022/07/15/InsertintoaBinarySearchTree/insert2.jpg" alt="Accepted tree"></p>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>We just need to follow the rules of the binary search tree to traverse and insert nodes when we encounter empty nodes.</p>
<p>For example, insert element 10, we need to find the last node to insert it, the same reasoning to insert element 15, insert element 0, insert element 6. </p>
<p><img src="/2022/07/15/InsertintoaBinarySearchTree/insert3.jpg" alt="Insert 10"></p>
<p><img src="/2022/07/15/InsertintoaBinarySearchTree/insert4.jpg" alt="Insert 15"></p>
<p><img src="/2022/07/15/InsertintoaBinarySearchTree/insert5.jpg" alt="Insert 0"></p>
<p><img src="/2022/07/15/InsertintoaBinarySearchTree/insert6.jpg" alt="Insert 6"></p>
<p>The next step is the process of traversing the binary search tree:</p>
<h3 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h3><ol>
<li><strong>Determine the parameters and return value of the recursive function:</strong></li>
</ol>
<p> The parameters are the root node pointer, and the element to be inserted.<br>We can use the return value to complete the assignment of the newly added node to its parent node<br>The return type of the recursive function is the node type <strong>TreeNode</strong>*</p>
   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>Determine the termination condition:</strong><br>The termination condition is to find the position of the node to be inserted when the traversed node is <strong>null</strong>, and to return the inserted node</li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>The logic for determining the single-level recursion:</strong></li>
</ol>
<p> We do not need to traverse the whole search tree.<br>Because the search tree is directed, the direction of recursion can be determined by the value of the inserted elements.</p>
   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>&amp;C++</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h3><p><strong>&amp;C++</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* parent = root; <span class="comment">//  we need to record last node, otherise we cannot give value to new node</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val &gt; val) cur = cur-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (val &lt; parent-&gt;val) parent-&gt;left = node;<span class="comment">//  Use parent node to give value</span></span><br><span class="line">        <span class="keyword">else</span> parent-&gt;right = node;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="amp-Java"><a href="#amp-Java" class="headerlink" title="&amp;Java"></a>&amp;Java</h3><p><strong>Recursion</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        TreeNode newRoot = root;</span><br><span class="line">        TreeNode pre = root;</span><br><span class="line">        <span class="keyword">while</span> (root != null) &#123;</span><br><span class="line">            pre = root;</span><br><span class="line">            <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre.val &gt; val) &#123;</span><br><span class="line">            pre.left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre.right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Iteration</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) <span class="comment">// if this node is empty, which means val finds the suitable position, return new node</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; val)&#123;</span><br><span class="line">            root.right = <span class="built_in">insertIntoBST</span>(root.right, val); <span class="comment">// create right subtree</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; val)&#123;</span><br><span class="line">            root.left = <span class="built_in">insertIntoBST</span>(root.left, val); <span class="comment">// create left subtree</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="amp-Python"><a href="#amp-Python" class="headerlink" title="&amp;Python"></a>&amp;Python</h3><p><strong>Recursion</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"><span class="meta"># class TreeNode:</span></span><br><span class="line"><span class="meta">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="meta">#         self.val = val</span></span><br><span class="line"><span class="meta">#         self.left = left</span></span><br><span class="line"><span class="meta">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="function">def <span class="title">insertIntoBST</span><span class="params">(self, root: TreeNode, val: <span class="type">int</span>)</span> -&gt; TreeNode:</span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        # Base Case</span></span><br><span class="line"><span class="function">        if not root: return TreeNode(val)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        if val &lt; root.val: </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">            root.left =</span> self.<span class="built_in">insertIntoBST</span>(root.left, val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">   </span><br><span class="line">            root.right = self.<span class="built_in">insertIntoBST</span>(root.right, val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p><strong>Iteration</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="function">def <span class="title">insertIntoBST</span><span class="params">(self, root: TreeNode, val: <span class="type">int</span>)</span> -&gt; TreeNode:</span></span><br><span class="line"><span class="function">        if not root: </span></span><br><span class="line"><span class="function">            return TreeNode(val)</span></span><br><span class="line"><span class="function">        parent =</span> None</span><br><span class="line">        cur = root</span><br><span class="line"></span><br><span class="line">        <span class="meta">#use while loop to find the parent of new node </span></span><br><span class="line">        <span class="keyword">while</span> cur: </span><br><span class="line">            <span class="keyword">if</span> cur.val &lt; val: </span><br><span class="line">                parent = cur</span><br><span class="line">                cur = cur.right</span><br><span class="line">            elif cur.val &gt; val: </span><br><span class="line">                parent = cur</span><br><span class="line">                cur = cur.left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta"># the parent of new node has been found</span></span><br><span class="line">        <span class="keyword">if</span> parent.val &gt; val: </span><br><span class="line">            parent.left = <span class="built_in">TreeNode</span>(val)</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            parent.right = <span class="built_in">TreeNode</span>(val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-06-29T23:00:00.000Z" title="30/06/2022, 00:00:00">2022-06-30</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">6 minutes read (About 971 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/06/30/MergeTwoBinaryTrees/">Merge Two Binary Trees</a></h1><div class="content"><h3 id="TEST-YOURSELF"><a href="#TEST-YOURSELF" class="headerlink" title="TEST YOURSELF"></a>TEST YOURSELF</h3><p>You are given two binary trees <strong>root1</strong> and <strong>root2</strong>.</p>
<p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p>
<p>Return the <strong>merged tree</strong>.</p>
<p>Note: The merging process must start from the root nodes of both trees.</p>
<p>Example 1:</p>
<p><img src="/2022/06/30/MergeTwoBinaryTrees/merge1.jpg" alt="Example 1"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]</span><br><span class="line">Output: [3,4,5,5,4,null,7]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>It’s actually the <strong>same</strong> logic as traversing a tree, except that the nodes of both trees are passed in and operated on <strong>simultaneously</strong>.</p>
<h3 id="Resursion"><a href="#Resursion" class="headerlink" title="Resursion"></a>Resursion</h3><p>Use pre-order as an example:</p>
<p><img src="/2022/06/30/MergeTwoBinaryTrees/merge2.jpg" alt="Merge trees by Pre-order Traversal1"></p>
<p><img src="/2022/06/30/MergeTwoBinaryTrees/merge3.jpg" alt="Merge trees by Pre-order Traversal2"></p>
<p><img src="/2022/06/30/MergeTwoBinaryTrees/merge4.jpg" alt="Merge trees by Pre-order Traversal3"></p>
<ol>
<li><strong>Determine the parameters and return value of the recursive function:</strong> To merge two binary trees, then the argument is <em><strong>passed at least the root node of both binary trees</strong></em>, and the return value is the root node of the merged binary tree.</li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li><strong>Determine the termination condition:</strong> Since two trees are passed in, there will be two trees traversing nodes t1 and t2.</li>
</ol>
<p>  If t1 &#x3D;&#x3D; NULL, the two trees will be merged into t2 (it doesn’t matter if t2 is also NULL, it will be NULL after the merge).</p>
<p> If t2 &#x3D;&#x3D; NULL, then the two numbers are merged into t1 (it doesn’t matter if t1 is also NULL, the merge is NULL).</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2; </span><br><span class="line"><span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1; </span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>The logic for determining the single-level recursion</strong>:<br> Adding the elements of two trees together</li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1-&gt;val += t2-&gt;val;</span><br></pre></td></tr></table></figure>

<p>The l<strong>eft subtree of t1</strong> is: the left subtree after merging the left subtree of t1 and the left subtree of t2.</p>
<p>The <strong>right subtree of t1</strong> is: the right subtree after merging the right subtree of t1 and the right subtree of t2.</p>
<p>The <strong>final t1</strong> is the <em><strong>root</strong></em> node after the merge.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1-&gt;left = <span class="built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);</span><br><span class="line">t1-&gt;right = <span class="built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);</span><br><span class="line"><span class="keyword">return</span> t1;</span><br></pre></td></tr></table></figure>

<p><strong>&amp;C++</strong></p>
<p> Complete code</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="comment">// re-define new node, don&#x27;t modity structure of the 2 old tree</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        root-&gt;val = t1-&gt;val + t2-&gt;val;</span><br><span class="line">        root-&gt;left = <span class="built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);</span><br><span class="line">        root-&gt;right = <span class="built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h3><p><strong>&amp;C++</strong></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(t1);</span><br><span class="line">        que.<span class="built_in">push</span>(t2);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node1 = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* node2 = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// add val</span></span><br><span class="line">            node1-&gt;val += node2-&gt;val;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if thel left node of 2 trees are both not empty, enter queue</span></span><br><span class="line">            <span class="keyword">if</span> (node1-&gt;left != <span class="literal">NULL</span> &amp;&amp; node2-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(node1-&gt;left);</span><br><span class="line">                que.<span class="built_in">push</span>(node2-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if thel right node of 2 trees are both noe empty, enter queue</span></span><br><span class="line">            <span class="keyword">if</span> (node1-&gt;right != <span class="literal">NULL</span> &amp;&amp; node2-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(node1-&gt;right);</span><br><span class="line">                que.<span class="built_in">push</span>(node2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">	            <span class="comment">//  when left node of t1=null, t2 !=null, set val</span></span><br><span class="line">            <span class="keyword">if</span> (node1-&gt;left == <span class="literal">NULL</span> &amp;&amp; node2-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node1-&gt;left = node2-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// when right node of t1=null, t2 !=null, set val</span></span><br><span class="line">            <span class="keyword">if</span> (node1-&gt;right == <span class="literal">NULL</span> &amp;&amp; node2-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node1-&gt;right = node2-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>xxxxxxxxxx import collectionsclass solution:    def maxdepth(self, root: treenode) -&gt; int:        if not root:            return 0        depth &#x3D; 0 #record depth        queue &#x3D; collections.deque()        queue.append(root)        while queue:            size &#x3D; len(queue)            depth +&#x3D; 1            for i in range(size):                node &#x3D; queue.popleft()                if node.left:                    queue.append(node.left)                if node.right:                    queue.append(node.right)        return depthcpp</p>
<p><strong>Recursion</strong></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == null) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span> (root2 == null) <span class="keyword">return</span> root1;</span><br><span class="line"></span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">        root1.left = <span class="built_in">mergeTrees</span>(root1.left,root2.left);</span><br><span class="line">        root1.right = <span class="built_in">mergeTrees</span>(root1.right,root2.right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Iteration</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// using queue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == null) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span> (root2 ==null) <span class="keyword">return</span> root1;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.<span class="built_in">offer</span>(root1);</span><br><span class="line">        queue.<span class="built_in">offer</span>(root2);</span><br><span class="line">        <span class="keyword">while</span> (!queue.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            TreeNode node1 = queue.<span class="built_in">poll</span>();</span><br><span class="line">            TreeNode node2 = queue.<span class="built_in">poll</span>();</span><br><span class="line">           </span><br><span class="line">            node1.val = node1.val + node2.val;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node1.left != null &amp;&amp; node2.left != null) &#123;</span><br><span class="line">                queue.<span class="built_in">offer</span>(node1.left);</span><br><span class="line">                queue.<span class="built_in">offer</span>(node2.left);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (node1.right != null &amp;&amp; node2.right != null) &#123;</span><br><span class="line">                queue.<span class="built_in">offer</span>(node1.right);</span><br><span class="line">                queue.<span class="built_in">offer</span>(node2.right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node1.left == null &amp;&amp; node2.left != null) &#123;</span><br><span class="line">                node1.left = node2.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node1.right == null &amp;&amp; node2.right != null) &#123;</span><br><span class="line">                node1.right = node2.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>&amp;Python</strong></p>
<p><strong>Recursion</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"><span class="meta"># class TreeNode:</span></span><br><span class="line"><span class="meta">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="meta">#         self.val = val</span></span><br><span class="line"><span class="meta">#         self.left = left</span></span><br><span class="line"><span class="meta">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="function">def <span class="title">mergeTrees</span><span class="params">(self, root1: TreeNode, root2: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line"><span class="function">       </span></span><br><span class="line"><span class="function">        if not root1: </span></span><br><span class="line"><span class="function">            return root2</span></span><br><span class="line"><span class="function">        if not root2: </span></span><br><span class="line"><span class="function">            return root1</span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">        root1.val +=</span> root2.val # 中</span><br><span class="line">        root1.left = self.<span class="built_in">mergeTrees</span>(root1.left, root2.left) <span class="meta">#left</span></span><br><span class="line">        root1.right = self.<span class="built_in">mergeTrees</span>(root1.right, root2.right) <span class="meta"># right</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root1</span><br></pre></td></tr></table></figure>

<p><strong>Iteration</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="function">def <span class="title">mergeTrees</span><span class="params">(self, root1: TreeNode, root2: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line"><span class="function">        if not root1: </span></span><br><span class="line"><span class="function">            return root2</span></span><br><span class="line"><span class="function">        if not root2: </span></span><br><span class="line"><span class="function">            return root1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        queue =</span> <span class="built_in">deque</span>()</span><br><span class="line">        queue.<span class="built_in">append</span>(root1)</span><br><span class="line">        queue.<span class="built_in">append</span>(root2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue: </span><br><span class="line">            node1 = queue.<span class="built_in">popleft</span>()</span><br><span class="line">            node2 = queue.<span class="built_in">popleft</span>()</span><br><span class="line">            <span class="meta"># update queue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node1.left <span class="keyword">and</span> node2.left: </span><br><span class="line">                queue.<span class="built_in">append</span>(node1.left)</span><br><span class="line">                queue.<span class="built_in">append</span>(node2.left)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node1.right <span class="keyword">and</span> node2.right: </span><br><span class="line">                queue.<span class="built_in">append</span>(node1.right)</span><br><span class="line">                queue.<span class="built_in">append</span>(node2.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            node1.val += node2.val</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node1.left <span class="keyword">and</span> node2.left: </span><br><span class="line">                node1.left = node2.left</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node1.right <span class="keyword">and</span> node2.right: </span><br><span class="line">                node1.right = node2.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root1</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-06-13T23:00:00.000Z" title="14/06/2022, 00:00:00">2022-06-14</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">5 minutes read (About 737 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/06/14/MinimumDepthofBinaryTree/">Minimum Depth of Binary Tree</a></h1><div class="content"><h3 id="TEST-YOURSELF"><a href="#TEST-YOURSELF" class="headerlink" title="TEST YOURSELF"></a>TEST YOURSELF</h3><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<p><strong>Example 1:</strong></p>
<p><img src="/2022/06/14/MinimumDepthofBinaryTree/min1.jpg" alt="Example1"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">Output: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [<span class="number">2</span>,null,<span class="number">3</span>,null,<span class="number">4</span>,null,<span class="number">5</span>,null,<span class="number">6</span>]</span><br><span class="line">Output: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>Intuitively, it seems to be similar to finding the maximum depth, but in fact it is still quite <strong>different</strong>.</p>
<p>In the following explanation, we still use <strong>post-order</strong><br>traversal in the order of traversal (because we want to compare the results after the recursive returns)</p>
<p>We first need to understand the definition of <strong>minimum depth</strong>: the minimum depth is the number of nodes on the shortest path from the root node to the <strong>nearest leaf node</strong></p>
<p><img src="/2022/06/14/MinimumDepthofBinaryTree/min2.jpg" alt="minDepth is 3"></p>
<h3 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h3><ol>
<li><strong>Determine the parameters and return value of the recursive function:</strong> The parameter is the root node of the binary tree to be passed in, and the depth returned is of type <em><strong>int</strong></em>.</li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* node)</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>Determine the termination condition:</strong> if the node is empty, 0 is returned, indicating a height of 0.</li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>The logic for determining the single-level recursion</strong>:</li>
</ol>
<ul>
<li><p>xxxxxxxxxx class Solution {​    public int minSubArrayLen(int s, int[] nums) {        int left &#x3D; 0;        int sum &#x3D; 0;        int result &#x3D; Integer.MAX_VALUE;        for (int right &#x3D; 0; right &lt; nums.length; right++) {            sum +&#x3D; nums[right];            while (sum &gt;&#x3D; s) {                result &#x3D; Math.min(result, right - left + 1);                sum -&#x3D; nums[left++];            }        }        return result &#x3D;&#x3D; Integer.MAX_VALUE ? 0 : result;    }}cpp</p>
</li>
<li><p>Conversely, if the right subtree is empty and the left subtree is not empty, the minimum depth is: <strong>1 + the depth of the left subtree</strong>. </p>
</li>
<li><p>Finally, if neither the left nor the right subtree is empty, return <strong>the minimum depth of the left or right subtree+1</strong>.</p>
</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// it is not the most deep node when the left subtree is empty and the right subtree is not empty</span></span><br><span class="line"><span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right != <span class="literal">NULL</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + rightDepth;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// it is not the most deep node when the left subtree is not empty and the right subtree is empty</span></span><br><span class="line"><span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + leftDepth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> result = <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth);</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p><strong>&amp;C++</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h3><p>   <strong>&amp;C++</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth++; <span class="comment">// reord</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123;                     <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>   <strong>&amp;Java</strong></p>
<ul>
<li><strong>Resursion</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="built_in">minDepth</span>(root.left);</span><br><span class="line">        <span class="type">int</span> rightDepth = <span class="built_in">minDepth</span>(root.right);</span><br><span class="line">        <span class="keyword">if</span> (root.left == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightDepth + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftDepth + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// both left node and right node are not empty </span></span><br><span class="line">        <span class="keyword">return</span> Math.<span class="built_in">min</span>(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Iteration</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        deque.<span class="built_in">offer</span>(root);</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!deque.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = deque.<span class="built_in">size</span>();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode poll = deque.<span class="built_in">poll</span>();</span><br><span class="line">                <span class="keyword">if</span> (poll.left == null &amp;&amp; poll.right == null) &#123;</span><br><span class="line">#                     <span class="comment">// when iterate leaf node ,return directly. since it is level oreder traversal, this value is minimum</span></span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (poll.left != null) &#123;</span><br><span class="line">                    deque.<span class="built_in">offer</span>(poll.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (poll.right != null) &#123;</span><br><span class="line">                    deque.<span class="built_in">offer</span>(poll.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>   <strong>&amp;Python</strong></p>
<ul>
<li><strong>Resursion</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="function">def <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="type">int</span>:</span></span><br><span class="line"><span class="function">        if not root:</span></span><br><span class="line"><span class="function">            return <span class="number">0</span></span></span><br><span class="line"><span class="function">        if not root.left and not root.right:</span></span><br><span class="line"><span class="function">            return <span class="number">1</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        min_depth =</span> <span class="number">10</span>**<span class="number">9</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">#             min_depth = <span class="built_in">min</span>(self.<span class="built_in">minDepth</span>(root.left), min_depth) <span class="meta"># the minimum depth of left subtree</span></span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            min_depth = <span class="built_in">min</span>(self.<span class="built_in">minDepth</span>(root.right), min_depth) <span class="meta"># the minimum depth of right subtree</span></span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Iteration</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="function">def <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="type">int</span>:</span></span><br><span class="line"><span class="function">        if not root:</span></span><br><span class="line"><span class="function">            return <span class="number">0</span></span></span><br><span class="line"><span class="function">        if not root.left and not root.right:</span></span><br><span class="line"><span class="function">            return <span class="number">1</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        min_depth =</span> <span class="number">10</span>**<span class="number">9</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            min_depth = <span class="built_in">min</span>(self.<span class="built_in">minDepth</span>(root.left), min_depth) <span class="meta"># the minimum depth of left subtree</span></span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            min_depth = <span class="built_in">min</span>(self.<span class="built_in">minDepth</span>(root.right), min_depth) <span class="meta"># the minimum depth of right subtree</span></span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span></span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-30T23:00:00.000Z" title="31/05/2022, 00:00:00">2022-05-31</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">4 minutes read (About 666 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/31/MaximumDepthofBinaryTree/">Maximum Depth of Binary Tree</a></h1><div class="content"><h3 id="TEST-YOURSELF"><a href="#TEST-YOURSELF" class="headerlink" title="TEST YOURSELF"></a>TEST YOURSELF</h3><p>Given the <strong>root</strong> of a binary tree, return its maximum depth.</p>
<p>A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p>Example1:</p>
<p><img src="/2022/05/31/MaximumDepthofBinaryTree/maxeg1.jpg" alt="Example1"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><h3 id="Resursion"><a href="#Resursion" class="headerlink" title="Resursion"></a>Resursion</h3><p>The problem can be solved using either <strong>preorder</strong> (parent left and right) or <strong>postorder</strong> traversal (left and right parent), using preorder to find the <strong>depth</strong> and postorder to find the <strong>height</strong>.</p>
<ul>
<li><strong>The depth of a binary tree node:</strong> the number of edges or nodes of the longest simple path from the root node to that node (depending on whether the depth starts at 0 or 1)</li>
<li><strong>The height of a binary tree node:</strong> the number of edges of the longest simple path from that node to the leaf node (depending on whether the height starts at 0 or 1)</li>
</ul>
<p>The height of the root node is the maximum depth of the binary tree, so in this problem we find the maximum depth of the binary tree by the height of the root node in the post-order.</p>
<p>we start with a post-order traversal (left and right middle) to calculate the height of the tree.</p>
<ol>
<li><strong>Determine the parameters and return value of the recursive function:</strong> the parameter is the root node of the incoming tree, and the return returns the depth of the tree, so the return value is of type int.<br>The code is as follows.</li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getdepth</span><span class="params">(treenode* node)</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>Determine the termination condition:</strong> if the node is empty, 0 is returned, indicating a height of 0.</li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>The logic for determining the single-level recursion</strong>: <em><strong>first</strong></em> find the depth of its left subtree, <em><strong>then</strong></em> the depth of its right subtree, and <em><strong>finally</strong></em> take the largest value of the left and right depths and add 1 (plus 1 because the current middle node is included) to the depth of the tree whose current node is the root node.</li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftdepth = <span class="built_in">getdepth</span>(node-&gt;left);       <span class="comment">// left</span></span><br><span class="line"><span class="type">int</span> rightdepth = <span class="built_in">getdepth</span>(node-&gt;right);     <span class="comment">// right</span></span><br><span class="line"><span class="type">int</span> depth = <span class="number">1</span> + <span class="built_in">max</span>(leftdepth, rightdepth); <span class="comment">// parent</span></span><br><span class="line"><span class="keyword">return</span> depth;</span><br></pre></td></tr></table></figure>
<p><strong>&amp;C++</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getdepth</span><span class="params">(treenode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftdepth = <span class="built_in">getdepth</span>(node-&gt;left);       <span class="comment">// left</span></span><br><span class="line">        <span class="type">int</span> rightdepth = <span class="built_in">getdepth</span>(node-&gt;right);     <span class="comment">// right</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span> + <span class="built_in">max</span>(leftdepth, rightdepth); <span class="comment">// parent</span></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(treenode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getdepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h3><p>Using the iterative method, it is most appropriate to use a <strong>level orde</strong>r traversal, because the **maximum depth **is the <em><strong>number of layers</strong></em> in the binary tree, which fits perfectly with the level order traversal.</p>
<p>As shown in the figure:</p>
<p><img src="/2022/05/31/MaximumDepthofBinaryTree/max1.jpg" alt="Max_depth By level order traversal"></p>
<h3 id="amp-C"><a href="#amp-C" class="headerlink" title="&amp;C++"></a>&amp;C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(treenode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        queue&lt;treenode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth++; <span class="comment">// record depth</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                treenode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>&amp;Java</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Resursion</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="built_in">maxDepth</span>(root.left);</span><br><span class="line">        <span class="type">int</span> rightDepth = <span class="built_in">maxDepth</span>(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.<span class="built_in">max</span>(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Iteration by level order traversal</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        deque.<span class="built_in">offer</span>(root);</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!deque.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = deque.<span class="built_in">size</span>();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode node = deque.<span class="built_in">poll</span>();</span><br><span class="line">                <span class="keyword">if</span> (node.left != null) &#123;</span><br><span class="line">                    deque.<span class="built_in">offer</span>(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != null) &#123;</span><br><span class="line">                    deque.<span class="built_in">offer</span>(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="amp-Python"><a href="#amp-Python" class="headerlink" title="&amp;Python"></a>&amp;Python</h3><p><strong>Resursion</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>:</span><br><span class="line">    <span class="function">def <span class="title">maxdepth</span><span class="params">(self, root: treenode)</span> -&gt; <span class="type">int</span>:</span></span><br><span class="line"><span class="function">        if not root:</span></span><br><span class="line"><span class="function">            return <span class="number">0</span></span></span><br><span class="line"><span class="function">        return <span class="number">1</span> + max(self.maxdepth(root.left), self.maxdepth(root.right))</span></span><br></pre></td></tr></table></figure>

<p><strong>Iteration</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>:</span><br><span class="line">    <span class="function">def <span class="title">maxdepth</span><span class="params">(self, root: treenode)</span> -&gt; <span class="type">int</span>:</span></span><br><span class="line"><span class="function">        if not root:</span></span><br><span class="line"><span class="function">            return <span class="number">0</span></span></span><br><span class="line"><span class="function">        depth =</span> <span class="number">0</span> <span class="meta">#record depth</span></span><br><span class="line">        queue = collections.<span class="built_in">deque</span>()</span><br><span class="line">        queue.<span class="built_in">append</span>(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i in <span class="built_in">range</span>(size):</span><br><span class="line">                node = queue.<span class="built_in">popleft</span>()</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.<span class="built_in">append</span>(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.<span class="built_in">append</span>(node.right)</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-29T23:00:00.000Z" title="30/04/2022, 00:00:00">2022-04-30</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">3 minutes read (About 407 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/LevelOrderTraversalofBinaryTree/">Level Order Traversal of Binary Tree</a></h1><div class="content"><p>Given the <strong>root</strong> of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level).</p>
<p><strong>Example1:</strong></p>
<p><img src="/2022/04/30/LevelOrderTraversalofBinaryTree/eg1.jpg" alt="Example1"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">Output: [[<span class="number">3</span>],[<span class="number">9</span>,<span class="number">20</span>],[<span class="number">15</span>,<span class="number">7</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Example2:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>]</span><br><span class="line">Output: [[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>Level order Traversal:<br> This means traversing the binary tree one layer at a time from left to right.<br>This is achieved by borrowing an auxiliary data structure: the queue, which is FIFO(first-in-first-out), in line with the logic of layer-by-layer traversal.</p>
<p>This level order traversal is the breadth-first traversal in graph theory, except that we apply it to binary trees.</p>
<p>A breadth-first traversal of a binary tree using a queue is as follows.</p>
<p><img src="/2022/04/30/LevelOrderTraversalofBinaryTree/fifo1.jpg" alt="FIFO_1"></p>
<p><img src="/2022/04/30/LevelOrderTraversalofBinaryTree/fifo2.jpg" alt="FIFO_2"></p>
<p><img src="/2022/04/30/LevelOrderTraversalofBinaryTree/fifo3.jpg" alt="FIFO_3"></p>
<p><img src="/2022/04/30/LevelOrderTraversalofBinaryTree/fifo4.jpg" alt="FIFO_4"></p>
<h3 id="amp-C"><a href="#amp-C" class="headerlink" title="&amp;C++"></a>&amp;C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// fixed siize(since que.size is changing)            for (int i = 0; i &lt; size; i++) &#123;</span></span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Iteration</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">order</span><span class="params">(TreeNode* cur, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() == depth) result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        result[depth].<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;left, result, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;right, result, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">order</span>(root, result, depth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="amp-Java"><a href="#amp-Java" class="headerlink" title="&amp;Java"></a>&amp;Java</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//checkFun01(root,0);</span></span><br><span class="line">        <span class="built_in">checkFun02</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DFS--Resursion</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">checkFun01</span><span class="params">(TreeNode node, Integer deep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == null) <span class="keyword">return</span>;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resList.<span class="built_in">size</span>() &lt; deep) &#123;</span><br><span class="line">            <span class="comment">//when number of level is larger,the item of list is larger. we use the index of list to distinguish diffrent levels</span></span><br><span class="line">            List&lt;Integer&gt; item = <span class="keyword">new</span> <span class="built_in">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            resList.<span class="built_in">add</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">        resList.<span class="built_in">get</span>(deep - <span class="number">1</span>).<span class="built_in">add</span>(node.val);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">checkFun01</span>(node.left, deep);</span><br><span class="line">        <span class="built_in">checkFun01</span>(node.right, deep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BFS--Iteration--use queue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">checkFun02</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == null) <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="built_in">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        que.<span class="built_in">offer</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            List&lt;Integer&gt; itemList = <span class="keyword">new</span> <span class="built_in">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> len = que.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode tmpNode = que.<span class="built_in">poll</span>();</span><br><span class="line">                itemList.<span class="built_in">add</span>(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tmpNode.left != null) que.<span class="built_in">offer</span>(tmpNode.left);</span><br><span class="line">                <span class="keyword">if</span> (tmpNode.right != null) que.<span class="built_in">offer</span>(tmpNode.right);</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resList.<span class="built_in">add</span>(itemList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">32</span></span></a></li><li><a class="level is-mobile" href="/categories/Deep-Learning/"><span class="level-start"><span class="level-item">Deep Learning</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Machine-learning/"><span class="level-start"><span class="level-item">Machine learning</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Video-Compression/"><span class="level-start"><span class="level-item">Video Compression</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-06-29T23:00:00.000Z">2023-06-30</time></p><p class="title"><a href="/2023/06/30/Model%20Compression-Pruning/">Model Compression - Pruning</a></p><p class="categories"><a href="/categories/Deep-Learning/">Deep Learning</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-06-14T23:00:00.000Z">2023-06-15</time></p><p class="title"><a href="/2023/06/15/BasicsofNeuralNetworksII/">Basics of Neural NetworksII</a></p><p class="categories"><a href="/categories/Deep-Learning/">Deep Learning</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-29T23:00:00.000Z">2023-05-30</time></p><p class="title"><a href="/2023/05/30/BasicsofNeuralNetworksI/">Basics of Neural NetworksI</a></p><p class="categories"><a href="/categories/Deep-Learning/">Deep Learning</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-13T23:00:00.000Z">2023-05-14</time></p><p class="title"><a href="/2023/05/14/Combinations-Pruning/IntroductiontoVideoCompression/">Introduction to Video Compression</a></p><p class="categories"><a href="/categories/Video-Compression/">Video Compression</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-13T23:00:00.000Z">2023-05-14</time></p><p class="title"><a href="/2023/05/14/IntroductiontoVideoCompression/">Introduction to Video Compression</a></p><p class="categories"><a href="/categories/Video-Compression/">Video Compression</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Array/"><span class="tag">Array</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BackTracking/"><span class="tag">BackTracking</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BinarySearchTree/"><span class="tag">BinarySearchTree</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BinaryTree/"><span class="tag">BinaryTree</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-C/"><span class="tag">C/C++</span><span class="tag">32</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Classification/"><span class="tag">Classification</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Combination/"><span class="tag">Combination</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CrossValidation/"><span class="tag">CrossValidation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DecisionTree/"><span class="tag">DecisionTree</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DeepLearning/"><span class="tag">DeepLearning</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DoublePointers/"><span class="tag">DoublePointers</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DynamicProgramming/"><span class="tag">DynamicProgramming</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/FeatureExtraction/"><span class="tag">FeatureExtraction</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/FeaturePreprocessing/"><span class="tag">FeaturePreprocessing</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GreedyAlgorithm/"><span class="tag">GreedyAlgorithm</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Iteration/"><span class="tag">Iteration</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">30</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KNN/"><span class="tag">KNN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LinkedList/"><span class="tag">LinkedList</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linkedlist/"><span class="tag">Linkedlist</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NaiveBayes/"><span class="tag">NaiveBayes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Optimization/"><span class="tag">Optimization</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Pruning/"><span class="tag">Pruning</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Resursion/"><span class="tag">Resursion</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/String/"><span class="tag">String</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TraversalOfBinaryTree/"><span class="tag">TraversalOfBinaryTree</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VideoCompression/"><span class="tag">VideoCompression</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/loop-invariant/"><span class="tag">loop invariant</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/machinelearning/"><span class="tag">machinelearning</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/modelcompression/"><span class="tag">modelcompression</span><span class="tag">5</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="Tianhao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Tianhao</p><p class="is-size-6 is-block">a MATH and CS student</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Bristol, United Kingdom</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">41</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">31</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/jasminepp/jasminepp.github.io" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/jasminepp/jasminepp.github.io"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">June 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">May 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">April 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">March 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">February 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">January 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">December 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">November 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/09/"><span class="level-start"><span class="level-item">September 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/08/"><span class="level-start"><span class="level-item">August 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">July 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">June 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">October 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Tianhao&#039;Site</a><p class="is-size-7"><span>&copy; 2023 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="jasmine"></script><script src="jasmine"></script><script src="jasmine" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>