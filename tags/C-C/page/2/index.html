<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Tag: C/C++ - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">C/C++</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-27T23:00:00.000Z" title="28/03/2022, 00:00:00">2022-03-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-05T22:22:47.192Z" title="05/10/2022, 23:22:47">2022-10-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">4 minutes read (About 527 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/03/28/BinaryTreeBasic/">Binary Tree Basic</a></h1><div class="content"><h3 id="What-is-Binary-Tree-Data-Structure"><a href="#What-is-Binary-Tree-Data-Structure" class="headerlink" title="What is Binary Tree Data Structure?"></a>What is Binary Tree Data Structure?</h3><p><strong>Binary Tree</strong> is defined as a Tree data structure with at most 2 children. Since each element in a binary tree can have only 2 children, we typically name them the left and right child.</p>
<h2 id="The-Type-of-Binary-Trees"><a href="#The-Type-of-Binary-Trees" class="headerlink" title="The Type of Binary Trees"></a>The Type of Binary Trees</h2><h3 id="1-Full-Binary-Tree"><a href="#1-Full-Binary-Tree" class="headerlink" title="1. Full Binary Tree"></a>1. Full Binary Tree</h3><p>  <strong>k-ary tree</strong>:  A (rooted) tree is k-ary if every node has at most k children. If k &#x3D; 2 then the tree is called binary.<br>  A k ary tree is <strong>full</strong> if every internal node has exactly k children</p>
<p> <img src="/2022/03/28/BinaryTreeBasic/full.jpg" alt="Full 3-ary Tree"></p>
<h3 id="2-Complete-Binary-Tree"><a href="#2-Complete-Binary-Tree" class="headerlink" title="2. Complete Binary Tree"></a>2. Complete Binary Tree</h3><p>  <strong>complete</strong> if all levels except possibly the last is entirely filled (and last level is filled from left to right)</p>
<p>  <img src="/2022/03/28/BinaryTreeBasic/complete.jpg" alt="Complete 3-ary Tree"></p>
<h3 id="3-Binary-Search-Tree"><a href="#3-Binary-Search-Tree" class="headerlink" title="3. Binary Search Tree"></a>3. Binary Search Tree</h3><p>The trees described earlier have no values, while a binary search tree <strong>has values</strong>. A binary search tree is an <em><strong>ordered tree</strong></em>.</p>
<ul>
<li>if its left subtree is not empty, the values of all nodes in the left subtree are less than the value of its root node.</li>
<li>if its right subtree is not empty, the values of all nodes in the right subtree are greater than the value of its root node.</li>
</ul>
<p>Its left and right subtrees are also each binary sorted trees</p>
<p>The following two trees are both search trees:<br><img src="/2022/03/28/BinaryTreeBasic/search.jpg" alt="Binary Search Tree"></p>
<h3 id="4-Balanced-Binary-Tree"><a href="#4-Balanced-Binary-Tree" class="headerlink" title="4. Balanced Binary Tree"></a>4. Balanced Binary Tree</h3><p>Balanced Binary Tree：also known as an AVL (Adelson-Velsky and Landis) tree and has the following properties: </p>
<ul>
<li>it is an empty tree <strong>or</strong></li>
<li>the difference in <strong>height</strong> between its left and right subtrees does not exceed <strong>1</strong>in absolute value </li>
<li>both left and right subtrees are a balanced binary tree.</li>
</ul>
<p>as shown：<br><img src="/2022/03/28/BinaryTreeBasic/AVL.jpg" alt="Balanced Binary Tree"></p>
<p>The last one is not a balanced binary tree because the absolute value of the difference between the heights of its left and right subtrees exceeds 1.</p>
<h2 id="How-binary-trees-are-stored"><a href="#How-binary-trees-are-stored" class="headerlink" title="How binary trees are stored"></a>How binary trees are stored</h2><p>There are two types of storage for binary trees.</p>
<ul>
<li><strong>Linked storage</strong>(pointer)</li>
<li><strong>Sequential storage</strong>(array)</li>
</ul>
<p><em><strong>Sequential storage</strong></em> has a <em>continuous</em> distribution of elements in memory, whereas <em><strong>linked storage</strong></em> has a series of nodes distributed at scattered addresses by means of <strong>pointers</strong>.</p>
<p><img src="/2022/03/28/BinaryTreeBasic/linked.jpg" alt="Linked storage"></p>
<p><img src="/2022/03/28/BinaryTreeBasic/seq1.jpg" alt="Sequential storage"><br><img src="/2022/03/28/BinaryTreeBasic/seq2.jpg" alt="Array Storage"></p>
<p><strong>How does using an array to store a binary tree traverse?</strong></p>
<p>If the parent node’s array subscript is i, then its left child is i * 2 + 1 and its right child is i * 2 + 2.</p>
<h2 id="Traversing-Binary-Tree"><a href="#Traversing-Binary-Tree" class="headerlink" title="Traversing Binary Tree"></a>Traversing Binary Tree</h2><p>There are <strong>two</strong> main types of traversal of a binary tree.</p>
<ol>
<li><em><strong>Depth-first traversal</strong></em>: go deeper first, then back when you encounter a leaf node.</li>
</ol>
<ul>
<li>Pre-order traversal (recursive, iterative )</li>
<li>In-order traversal (recursive, iterative)</li>
<li>Post-order traversal (recursive, iterative)</li>
</ul>
<ol start="2">
<li><em><strong>Breadth-first traversa</strong></em>l: go through layer by layer.<br> Level Order traversal (iterative)</li>
</ol>
<h2 id="The-Definition-of-Binary-Tree"><a href="#The-Definition-of-Binary-Tree" class="headerlink" title="The Definition of Binary Tree"></a>The Definition of Binary Tree</h2><h3 id="amp-C"><a href="#amp-C" class="headerlink" title="&amp;C++"></a>&amp;C++</h3><pre><code class="cpp">struct TreeNode &#123;
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
&#125;;
</code></pre>
<h3 id="amp-Java"><a href="#amp-Java" class="headerlink" title="&amp;Java"></a>&amp;Java</h3><pre><code class="cpp">public class TreeNode &#123;
    int val;
      TreeNode left;
      TreeNode right;
      TreeNode() &#123;&#125;
      TreeNode(int val) &#123; this.val = val; &#125;
      TreeNode(int val, TreeNode left, TreeNode right) &#123;
            this.val = val;
            this.left = left;
            this.right = right;
      &#125;
&#125;
</code></pre>
<h3 id="amp-Python"><a href="#amp-Python" class="headerlink" title="&amp;Python"></a>&amp;Python</h3><pre><code class="cpp">class TreeNode: 
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-11T00:00:00.000Z" title="11/03/2022, 00:00:00">2022-03-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-03T11:51:42.758Z" title="03/10/2022, 12:51:42">2022-10-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">a few seconds read (About 66 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/03/11/RepeatedSubstringPattern(2)/">Repeated Substring Pattern(2)</a></h1><div class="content"><p>There is a problem with <strong><a target="_blank" rel="noopener" href="https://jasminepp.github.io/2022/02/28/RepeatedSubstringPattern(1)/">move matching</a></strong>:  we end up with the process of determining whether a string (<em><strong>s + s</strong></em>) has an occurrence of <em><strong>s</strong></em>. We could just use libraries like <em><strong>contains</strong></em>, <em><strong>find</strong></em> and so on. This ignores the time complexity of implementing these functions (the brute force solution is <strong>m * n</strong>, and the general library implementation is <strong>O(m + n))</strong></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-02-28T00:00:00.000Z" title="28/02/2022, 00:00:00">2022-02-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-05T22:22:55.677Z" title="05/10/2022, 23:22:55">2022-10-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">2 minutes read (About 321 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/28/RepeatedSubstringPattern(1)/">Repeated Substring Pattern(1)</a></h1><div class="content"><h3 id="TEST-YOURSELF"><a href="#TEST-YOURSELF" class="headerlink" title="TEST YOURSELF"></a>TEST YOURSELF</h3><p>Given a string <strong>s</strong>, check if it can be constructed by taking a substring of it and appending <strong>multiple copies</strong> of the substring together.</p>
<pre><code class="cpp">Example 1:

Input: s = &quot;abab&quot;
Output: true
Explanation: It is the substring &quot;ab&quot; twice.
</code></pre>
<pre><code class="cpp">Example 2:

Input: s = &quot;aba&quot;
Output: false
</code></pre>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>The violent solution is a for loop to get the termination position of the substring, and then to determine whether the substring can be repeated to form a string, nested in another for loop, so it is O(n^2) time complexity.</p>
<p><strong>Here is an Better solution: Move Matching</strong></p>
<h3 id="Move-Matching"><a href="#Move-Matching" class="headerlink" title="Move Matching"></a>Move Matching</h3><p>When a string <em><strong>s</strong></em>: abcabc is composed of repeated substrings within it, then the structure of the string must be such that:<br><img src="/2022/02/28/RepeatedSubstringPattern(1)/repeat1.jpg" alt="The structure of target s"></p>
<p>That is, it consists of the same substring before and after it.</p>
<p>Then since the same substring precedes and follows the same substring, using <strong>s + s.</strong><br>In a string thus formed, the later substring is treated as the previous string and the earlier substring as the later string, and there must still be an s formed, as in the figure:</p>
<p><img src="/2022/02/28/RepeatedSubstringPattern(1)/repeat2.jpg" alt="The structure of s+s"></p>
<p>So to determine whether the string <em><strong>s</strong></em> is composed of repeated substrings, as long as two <em><strong>s</strong></em>‘ s are spliced together and there is still an <em><strong>s</strong></em> in it, it means that <em><strong>s</strong></em> is composed of repeated substrings.</p>
<p>Of course, when we determine whether an <em><strong>s</strong></em> appears in the <em><strong>s + s</strong></em> spliced string, we shave off the first and last characters of <em><strong>s + s</strong></em>, so as to avoid searching for the original <em><strong>s</strong></em> in <em><strong>s + s</strong></em>. What we want to search for is the <em><strong>s</strong></em> spliced out in the middle.</p>
<h3 id="amp-C"><a href="#amp-C" class="headerlink" title="&amp;C++"></a>&amp;C++</h3><pre><code class="cpp">
class Solution &#123;
public:
    bool repeatedSubstringPattern(string s) &#123;
        string t = s + s;
        t.erase(t.begin()); t.erase(t.end() - 1); // remove head and tail
        if (t.find(s) != std::string::npos) return true; // r
        return false;
    &#125;
&#125;;
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-02-11T00:00:00.000Z" title="11/02/2022, 00:00:00">2022-02-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-05T22:22:56.233Z" title="05/10/2022, 23:22:56">2022-10-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">3 minutes read (About 470 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/11/Replacespaces/">Replace spaces</a></h1><div class="content"><h3 id="TEST-YOURSELF"><a href="#TEST-YOURSELF" class="headerlink" title="TEST YOURSELF"></a>TEST YOURSELF</h3><p>Please implement a function that replaces each <strong>space</strong> in the string <em><strong>s</strong></em> with <strong>“%20”</strong>.</p>
<pre><code class="cpp">Example 1:

Input: s = &quot;We are happy.&quot;
Output: &quot;We%20are%20happy.&quot;
</code></pre>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>The highlight of this puzzle is that <strong>no extra auxiliary space is used.</strong></p>
<p><strong>Step1:</strong> Expand the array to the size after each space has been replaced with “%20”.</p>
<p><img src="/2022/02/11/Replacespaces/step1.jpg" alt="Expand the size of the array"></p>
<p><strong>Step2:</strong> Replace the spaces <strong>from back to front</strong>, i.e. the <em>double pointer</em> method, as follows:</p>
<ul>
<li><strong>i</strong> points to the <strong>end</strong> of the <em><strong>new</strong></em> length and <strong>j</strong> points to the <strong>end</strong> of the <em><strong>old</strong></em> length.</li>
</ul>
<p><img src="/2022/02/11/Replacespaces/step2.jpg" alt="Replace spaces 1"></p>
<p><img src="/2022/02/11/Replacespaces/step3.jpg" alt="Replace spaces 2"></p>
<p><img src="/2022/02/11/Replacespaces/step4.jpg" alt="Replace spaces 3"></p>
<p><img src="/2022/02/11/Replacespaces/step5.jpg" alt="Replace spaces 4"></p>
<p><img src="/2022/02/11/Replacespaces/step6.jpg" alt="Replace spaces 5"></p>
<h3 id="Why-do-we-need-to-fill-from-back-to-front"><a href="#Why-do-we-need-to-fill-from-back-to-front" class="headerlink" title="Why do we need to fill from back to front?"></a>Why do we need to fill from back to front?</h3><p>Filling from front to back is an <strong>O(n^2)</strong> algorithm, because each time an element is added, all the elements after the added element are moved backwards</p>
<p>In fact, for many array padding problems, we can pre-fill the array with the size of the padding, and then work backwards and forwards.</p>
<p>Doing this has two <strong>advantage</strong>s:</p>
<ol>
<li>Don’t need to request new arrays.</li>
<li>By filling the elements backwards and forwards, we avoid having to move all the elements backwards after the added elements each time they are added.</li>
</ol>
<h3 id="amp-C"><a href="#amp-C" class="headerlink" title="&amp;C++"></a>&amp;C++</h3><pre><code class="cpp">class Solution &#123;
public:
    string replaceSpace(string s) &#123;
        int count = 0; // count the number of spaces
        int sOldSize = s.size();
        for (int i = 0; i &lt; s.size(); i++) &#123;
            if (s[i] == &#39; &#39;) &#123;
                count++;
            &#125;
        &#125;
        // expand the size of string s(after replacing 20%)
        s.resize(s.size() + count * 2);
        int sNewSize = s.size();
        
        // replace spaces with 20% from back to front
        for (int i = sNewSize - 1, j = sOldSize - 1; j &lt; i; i--, j--) &#123;
            if (s[j] != &#39; &#39;) &#123;
                s[i] = s[j];
            &#125; else &#123;
                s[i] = &#39;0&#39;;
                s[i - 1] = &#39;2&#39;;
                s[i - 2] = &#39;%&#39;;
                i -= 2;
            &#125;
        &#125;
        return s;
    &#125;
&#125;;
</code></pre>
<ul>
<li>Time Complexity：O(n)</li>
<li>Space Complexity：O(1)</li>
</ul>
<h3 id="amp-C-1"><a href="#amp-C-1" class="headerlink" title="&amp;C"></a>&amp;C</h3><pre><code class="cpp">char* replaceSpace(char* s)&#123;
   
    int count = 0;
    int len = strlen(s);
    for (int i = 0; i &lt; len; i++) &#123;
        if (s[i] == &#39; &#39;) &#123;
            count++;
        &#125;
    &#125;

    
    int newLen = len + count * 2;
    char* result = malloc(sizeof(char) * newLen + 1);
    
    
    for (int i = len - 1, j = newLen - 1; i &gt;= 0; i--, j--) &#123;
        if (s[i] != &#39; &#39;) &#123;
            result[j] = s[i];
        &#125; else &#123;
            result[j--] = &#39;0&#39;;
            result[j--] = &#39;2&#39;;
            result[j] = &#39;%&#39;;
        &#125;
    &#125;
    result[newLen] = &#39;\0&#39;;

    return result;
&#125;
</code></pre>
<h3 id="amp-Java"><a href="#amp-Java" class="headerlink" title="&amp;Java"></a>&amp;Java</h3><pre><code class="cpp">public String replaceSpace(String s) &#123;
    if(s == null || s.length() == 0)&#123;
        return s;
    &#125;
    //expand size, double number of spaces
    StringBuilder str = new StringBuilder();
    for (int i = 0; i &lt; s.length(); i++) &#123;
        if(s.charAt(i) == &#39; &#39;)&#123;
            str.append(&quot;  &quot;);
        &#125;
    &#125;
    // no space, return s
    if(str.length() == 0)&#123;
        return s;
    &#125;
    //double pointer
    int left = s.length() - 1;//left： point to end of the old string
    s += str.toString();
    int right = s.length()-1;//right：point to end of the new string    char[] chars = s.toCharArray();
    while(left&gt;=0)&#123;
        if(chars[left] == &#39; &#39;)&#123;
            chars[right--] = &#39;0&#39;;
            chars[right--] = &#39;2&#39;;
            chars[right] = &#39;%&#39;;
        &#125;else&#123;
            chars[right] = chars[left];
        &#125;
        left--;
        right--;
    &#125;
    return new String(chars);
&#125;
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-01-30T00:00:00.000Z" title="30/01/2022, 00:00:00">2022-01-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-05T22:22:56.976Z" title="05/10/2022, 23:22:56">2022-10-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">2 minutes read (About 278 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/01/30/ReverseString/">Reverse String</a></h1><div class="content"><h3 id="TEST-YOURSELF"><a href="#TEST-YOURSELF" class="headerlink" title="TEST YOURSELF"></a>TEST YOURSELF</h3><p>Write a function that <strong>reverses a string</strong>. The input string is given as an array of characters s.</p>
<p>You must do this by modifying the input array in-place with O(1) extra memory.</p>
<pre><code class="cpp">Example 1:

Input: s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]
</code></pre>
<pre><code class="cpp">Example 2:

Input: s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]
Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]
</code></pre>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>In inverting a linked list, the <strong>double pointer method</strong> is used.</p>
<p>Inverting strings is still done using the double pointer method, except that it is actually <strong>simpler</strong> to invert strings than list.</p>
<p>Since strings are also arrays, the elements are <strong>distributed continuously in memory</strong>, which makes the difference between inverting a chain table and inverting a string.</p>
<p>For strings, we define two pointers (or index subscripts), one from the front of the string and one from the back of the string, and both pointers move towards the middle at the same time and swap elements.</p>
<p>Using the string <em><strong>hello</strong></em> as an example, the procedure is as follows:</p>
<p><img src="/2022/01/30/ReverseString/rever1.jpg" alt="Reverse &quot;hello&quot;1"></p>
<p><img src="/2022/01/30/ReverseString/rever2.jpg" alt="Reverse &quot;hello&quot;2"></p>
<p><img src="/2022/01/30/ReverseString/rever3.jpg" alt="Reverse &quot;hello&quot;3"></p>
<h3 id="amp-C"><a href="#amp-C" class="headerlink" title="&amp;C++"></a>&amp;C++</h3><pre><code class="cpp">void reverseString(vector&lt;char&gt;&amp; s) &#123;
    for (int i = 0, j = s.size() - 1; i &lt; s.size()/2; i++, j--) &#123;
        swap(s[i],s[j]);
    &#125;
&#125;
</code></pre>
<h3 id="amp-Java"><a href="#amp-Java" class="headerlink" title="&amp;Java"></a>&amp;Java</h3><pre><code class="cpp">class Solution &#123;
    public void reverseString(char[] s) &#123;
        int l = 0;
        int r = s.length - 1;
        while (l &lt; r) &#123;
            s[l] ^= s[r];  
            s[r] ^= s[l];             
             s[l] ^= s[r];              
             l++;
#              r--;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="amp-Python"><a href="#amp-Python" class="headerlink" title="&amp;Python"></a>&amp;Python</h3><pre><code class="cpp">
class Solution:
    def reverseString(self, s: List[str]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify s in-place instead.
        &quot;&quot;&quot;
        left, right = 0, len(s) - 1
        while left &lt; right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-01-11T00:00:00.000Z" title="11/01/2022, 00:00:00">2022-01-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-05T22:22:52.239Z" title="05/10/2022, 23:22:52">2022-10-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">7 minutes read (About 1044 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/01/11/LinkedListCycle/">Linked List Cycle</a></h1><div class="content"><p>Given the <em><strong>head</strong></em> of a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.</p>
<p>Do not modify the linked list.</p>
<pre><code class="cpp">Example 1:

Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the second node.
</code></pre>
<p><img src="/2022/01/11/LinkedListCycle/example1.jpg" alt="Example1"></p>
<pre><code class="cpp">Example 2:

Input: head = [1,2], pos = 0
Output: tail connects to node index 0
Explanation: There is a cycle in the linked list, where tail connects to the first node.
</code></pre>
<p><img src="/2022/01/11/LinkedListCycle/example2.jpg" alt="Example2"></p>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>There are two main breakthrough points.</p>
<ul>
<li>Determining whether there is a ring in this linked list </li>
<li>If there is a ring, how to find the entrance to the ring</li>
</ul>
<h3 id="1-Determining-whether-there-is-a-ring-in-this-linked-list"><a href="#1-Determining-whether-there-is-a-ring-in-this-linked-list" class="headerlink" title="1. Determining whether there is a ring in this linked list"></a>1. Determining whether there is a ring in this linked list</h3><ol>
<li>We can use the <strong>fast and slow pointer method</strong> to define fast and slow pointers respectively, starting from the head node, the fast pointer <em><strong>moves two nodes</strong></em> at a time, the slow pointer <em><strong>moves one node</strong></em> at a time, if the fast and slow pointers <strong>meet</strong> on the way, it means that the list has a ring.</li>
</ol>
<ul>
<li>Why does the fast pointer move two nodes and the slow pointer move one node and if there is a ring, they must meet inside the ring, instead of always being <strong>staggered</strong>?</li>
</ul>
<p> First of all,  the fast pointer must enter the ring first. If the fast pointer and the slow pointer meet, <strong>they must meet in the ring</strong>, there is no doubt about that.</p>
<ul>
<li><p>So let’s see, why must the fast pointer and the slow pointer meet?</p>
<p>We can <strong>draw</strong> a ring and have the fast pointer start to catch up with the slow pointer at any one of the nodes.</p>
</li>
</ul>
<p> We will find that this is what happens in the end, as follows:</p>
<p><img src="/2022/01/11/LinkedListCycle/cycle1.jpg" alt="fast_slow pointers"></p>
<p>fast and slow each take one more step, and fast and slow meet</p>
<p>This is because fast takes two steps and slow takes one step. In fact, compared to slow, fast is approaching slow node by node, so fast must be able to overlap with slow.</p>
<p><img src="/2022/01/11/LinkedListCycle/cycle2.jpg" alt="fast_slow pointers move"></p>
<p><img src="/2022/01/11/LinkedListCycle/cycle3.jpg" alt="fast_slow pointers encounter"></p>
<h3 id="2-If-there-is-a-ring-how-to-find-the-entrance-to-the-ring"><a href="#2-If-there-is-a-ring-how-to-find-the-entrance-to-the-ring" class="headerlink" title="2. If there is a ring, how to find the entrance to the ring"></a>2. If there is a ring, how to find the entrance to the ring</h3><p>Assume that the number of nodes from the head node to the ring entry node is <strong>x</strong>. The number of nodes from the ring entry node to the node where the fast pointer meets the slow pointer is <strong>y</strong>. The number of nodes from the meeting node to the ring entry node is <strong>z</strong>. As shown in the figure.</p>
<p><img src="/2022/01/11/LinkedListCycle/cycle4.jpg" alt="fast_slow circular"></p>
<p>Then when the fast pointer and slow pointer meet: the number of nodes walked by the slow pointer is: <strong>x + y</strong>, the number of nodes walked by the fast pointer is: <strong>x + y + n (y + z)</strong>, n is the number of n turns in the ring before the fast pointer meets the slow pointer, and <strong>(y + z)</strong> is the number of nodes in a turn A.</p>
<p>Since the fast pointer takes two nodes in one step and the slow pointer takes one node in one step, the number of nodes taken by the fast pointer &#x3D; the number of nodes taken by the slow pointer * 2:</p>
<p><strong>(x + y) * 2 &#x3D; x + y + n (y + z)</strong></p>
<p>eliminating one <strong>(x + y)</strong> on both sides: <strong>x + y &#x3D; n (y + z)</strong></p>
<p>Since the entrance to the ring is to be found, then x is required because <strong>x</strong> represents the distance from the head node to the entrance node of the ring.</p>
<p>So put <strong>x</strong> alone on the left: <strong>x &#x3D; n (y + z) - y</strong> ,</p>
<p>Then from <strong>n(y + z)</strong>, we can put a <strong>(y + z)</strong>, and after sorting out the formula, we have the following formula: <strong>x &#x3D; (n - 1) (y + z) + z</strong>. <em><strong>Note that n must be larger than or equal to 1 here</strong></em>, because the fast pointer must move at least one more turn to meet the slow pointer.</p>
<h3 id="What-does-this-formula-show"><a href="#What-does-this-formula-show" class="headerlink" title="What does this formula show?"></a>What does this formula show?</h3><ul>
<li>where <strong>n is 1</strong>. This means that the fast pointer encounters the slow pointer after one turn in the loop.</li>
</ul>
<p>When n is 1, the formula resolves to <strong>x &#x3D; z</strong></p>
<p>This means that one pointer from the head node and one pointer from the meeting node, both of which go one node at a time, will be the node at the entrance to the ring when they meet.</p>
<p>This means that at the meeting node, a pointer index1 is defined, and at the head node, a pointer index2 is defined.</p>
<p>Let index1 and index2 move simultaneously, one node at a time, so that where they meet is the node at the entrance to the ring.</p>
<ul>
<li>where <strong>n is larger than 1</strong>, the fast pointer turns <em><strong>n times</strong></em> in the ring before encountering the slow pointer.</li>
</ul>
<p>In fact, the effect is the same as when n is 1. You can find the entrance node of the ring by this method, except that the index1 pointer takes an extra <strong>(n-1)</strong> turns in the ring and then meets index2, which is still the entrance node of the ring</p>
<h3 id="amp-C"><a href="#amp-C" class="headerlink" title="&amp;C++"></a>&amp;C++</h3><pre><code class="cpp">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode *detectCycle(ListNode *head) &#123;
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
               // exsit a ring
            if (slow == fast) &#123;
                ListNode* index1 = fast;
                ListNode* index2 = head;
                while (index1 != index2) &#123;
                    index1 = index1-&gt;next;
                    index2 = index2-&gt;next;
                &#125;
                return index2; // return the entrance of ring
            &#125;
        &#125;
        return NULL;
    &#125;
&#125;;
</code></pre>
<h3 id="amp-Java"><a href="#amp-Java" class="headerlink" title="&amp;Java"></a>&amp;Java</h3><pre><code class="cpp">public class Solution &#123;
    public ListNode detectCycle(ListNode head) &#123;
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null &amp;&amp; fast.next != null) &#123;
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) &#123;// exsit a ring
                ListNode index1 = fast;
                ListNode index2 = head;
                // the encounter nodeis the entrance of ring
                while (index1 != index2) &#123;
                    index1 = index1.next;
                    index2 = index2.next;
                &#125;
                return index1;
            &#125;
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-28T00:00:00.000Z" title="28/12/2021, 00:00:00">2021-12-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-05T22:22:56.627Z" title="05/10/2022, 23:22:56">2022-10-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">4 minutes read (About 640 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/28/ReverseLinkedList/">Reverse Linked List</a></h1><div class="content"><p>Given the <strong>head</strong> of a singly linked list, reverse the list, and return the <em>reversed list</em>.</p>
<pre><code class="cpp">Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
</code></pre>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>It would actually be a waste of memory space to define a new chain table and implement the inversion of the elements of the chain table.</p>
<p>In fact, you only need to change the pointing of the next pointer of the chain table to invert it directly without redefining a new chain table, as shown in the figure:<br>    <img src="/2021/12/28/ReverseLinkedList/reverse1.jpg" alt="Reverse a linked list"></p>
<p>Previously the head node of the chain was element 1, after reversing it the head node is element 5, no nodes are added or removed here, just the direction of the next pointer.</p>
<p><strong>Reverse flow:</strong></p>
<ol>
<li><p>Firstly, define a cur pointer to the head node, and a pre pointer, initialized to null.</p>
</li>
<li><p>Then it’s time to reverse the process, first by saving the cur-&gt;next node with the tmp pointer, that is, by saving this node.</p>
</li>
<li><p>Why save this node?  Because the next step is to change the cur-&gt;next pointer, so that cur-&gt;next points to pre, which has already reversed the first node.</p>
</li>
<li><p>The next step is to loop through the following code logic, continuing to move the pre and cur pointers.</p>
</li>
<li><p>Finally, the cur pointer is pointing to null, the loop is over and the chain is reversed. At this point we return the pre pointer and the pre pointer points to the new head node.</p>
</li>
</ol>
<h3 id="amp-C"><a href="#amp-C" class="headerlink" title="&amp;C++"></a>&amp;C++</h3><p><strong>1.Double Pointer</strong></p>
<pre><code class="cpp">
class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        ListNode* temp; // 保存cur的下一个节点
        ListNode* cur = head;
        ListNode* pre = NULL;
        while(cur) &#123;
            temp = cur-&gt;next;  // 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next
            cur-&gt;next = pre; // 翻转操作
            // 更新pre 和 cur指针
            pre = cur;
            cur = temp;
        &#125;
        return pre;
    &#125;
&#125;;
</code></pre>
<p><strong>2.Recursion</strong></p>
<pre><code class="cpp">
public:
    ListNode* reverse(ListNode* pre,ListNode* cur)&#123;
        if(cur == NULL) return pre;
        ListNode* temp = cur-&gt;next;
        cur-&gt;next = pre;
        // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步
        // pre = cur;
        // cur = temp;
        return reverse(cur,temp);
    &#125;
    ListNode* reverseList(ListNode* head) &#123;
        // 和双指针法初始化是一样的逻辑
        // ListNode* cur = head;
        // ListNode* pre = NULL;
        return reverse(NULL, head);
    &#125;

&#125;;
</code></pre>
<h3 id="amp-Java"><a href="#amp-Java" class="headerlink" title="&amp;Java"></a>&amp;Java</h3><p><strong>1.Double Pointer</strong></p>
<pre><code class="cpp">
class Solution &#123;
    public ListNode reverseList(ListNode head) &#123;
        ListNode prev = null;
        ListNode cur = head;
        ListNode temp = null;
        while (cur != null) &#123;
            temp = cur.next;// 保存下一个节点
            cur.next = prev;
            prev = cur;
            cur = temp;
        &#125;
        return prev;
    &#125;
&#125;
</code></pre>
<p><strong>2.Recursion</strong></p>
<pre><code class="cpp">
class Solution &#123;
    public ListNode reverseList(ListNode head) &#123;
        return reverse(null, head);
    &#125;

    private ListNode reverse(ListNode prev, ListNode cur) &#123;
        if (cur == null) &#123;
            return prev;
        &#125;
        ListNode temp = null;
        temp = cur.next;// 先保存下一个节点
        cur.next = prev;// 反转
        // 更新prev、cur位置
        // prev = cur;
        // cur = temp;
        return reverse(cur, temp);
    &#125;
&#125;
</code></pre>
<h3 id="amp-Python"><a href="#amp-Python" class="headerlink" title="&amp;Python"></a>&amp;Python</h3><p><strong>1.Double Pointer</strong></p>
<pre><code class="cpp">
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        cur = head   
        pre = None
        while(cur!=None):
            temp = cur.next # 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next
            cur.next = pre #反转
            #更新pre、cur指针
            pre = cur
            cur = temp
        return pre
</code></pre>
<p><strong>2.Recursion</strong></p>
<pre><code class="cpp">
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        
        def reverse(pre,cur):
            if not cur:
                return pre
                
            tmp = cur.next
            cur.next = pre

            return reverse(cur,tmp)
        
        return reverse(None,head)
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-28T00:00:00.000Z" title="28/12/2021, 00:00:00">2021-12-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-05T23:22:44.000Z" title="06/10/2022, 00:22:44">2022-10-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">2 minutes read (About 334 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/28/SwapNodesinPairs/">Swap Nodes in Pairs</a></h1><div class="content"><p>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">Input: head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">Output: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">Input: head = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>We can draw a diagram to avoid confusion</p>
<p>Initially, cur points to the dummy head node, and then the following three steps are performed.</p>
<p><img src="/change1.jpg" alt="Exchange Flow1"></p>
<p>After the operation, the linked list looks like this.</p>
<p><img src="/change2.jpg" alt="Exchange Flow2"></p>
<p>It might be a little more intuitive to look at this:</p>
<p><img src="/change3.jpg" alt="Exchange Flow3"></p>
<h3 id="amp-C"><a href="#amp-C" class="headerlink" title="&amp;C++"></a>&amp;C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>); <span class="comment">// set a dummy node</span></span><br><span class="line">        dummyHead-&gt;next = head; <span class="comment">//  let dummy node point to head so t hat we can operate deletion</span></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next; <span class="comment">// record temp node</span></span><br><span class="line">            ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next; <span class="comment">//record temp node</span></span><br><span class="line"></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;    <span class="comment">// Step1</span></span><br><span class="line">            cur-&gt;next-&gt;next = tmp;          <span class="comment">// Step2</span></span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = tmp1;   <span class="comment">// Step3</span></span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next; <span class="comment">// cur node moves 2 places, which prepare to next change operation</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity: O(n)</strong></p>
<p><strong>Space Complexity: O(1)</strong></p>
<h3 id="amp-Java"><a href="#amp-Java" class="headerlink" title="&amp;Java"></a>&amp;Java</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Resursion</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case </span></span><br><span class="line">        <span class="keyword">if</span>(head == null || head.next == null) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// get next node of this node</span></span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        <span class="comment">// recursion</span></span><br><span class="line">        ListNode newNode = <span class="built_in">swapPairs</span>(next.next);</span><br><span class="line">        <span class="comment">// change operation</span></span><br><span class="line">        next.next = head;</span><br><span class="line">        head.next = newNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dummy node</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ListNode dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    ListNode prev = dummyNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (prev.next != null &amp;&amp; prev.next.next != null) &#123;</span><br><span class="line">      ListNode temp = head.next.next; <span class="comment">// temp next node</span></span><br><span class="line">      prev.next = head.next;          <span class="comment">// let next of prev change to next of head </span></span><br><span class="line">      head.next.next = head;          <span class="comment">// let next of head.next(prev.next) points to head</span></span><br><span class="line">      head.next = temp;               <span class="comment">// let temp of head =temp</span></span><br><span class="line">      prev = head;                    <span class="comment">// move forward 1 place</span></span><br><span class="line">      head = head.next;               <span class="comment">// move forward 1 place</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2021/12/09/DesignLinkedList/"><img class="fill" src="/gallery/covers/cover.jpg" alt="Design Linked List"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-09T00:00:00.000Z" title="09/12/2021, 00:00:00">2021-12-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-05T22:22:48.953Z" title="05/10/2022, 23:22:48">2022-10-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">9 minutes read (About 1275 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/09/DesignLinkedList/">Design Linked List</a></h1><div class="content"><p>Implement the MyLinkedList class:</p>
<ul>
<li><p><em><strong>int get(int index)</strong></em> Get the value of the indexth node in the linked list. If the index is invalid, return -1.</p>
</li>
<li><p><em><strong>void addAtHead(int val)</strong></em> Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</p>
</li>
<li><p><em><strong>void addAtTail(int val)</strong></em>  Append a node of value val as the last element of the linked list.</p>
</li>
<li><p><em><strong>void addAtIndex(int index, int val)</strong></em> Add a node of value val before the indexth node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted.</p>
</li>
<li><p><strong>void deleteAtIndex(int index</strong>) Delete the indexth node in the linked list, if the index is valid.</p>
</li>
</ul>
<pre><code class="cpp">Example:

Input
[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]
[[], [1], [3], [1, 2], [1], [1], [1]]
Output
[null, null, null, null, 2, null, 3]

Explanation
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // linked list becomes 1-&gt;2-&gt;3
myLinkedList.get(1);              // return 2
myLinkedList.deleteAtIndex(1);    // now the linked list is 1-&gt;3
myLinkedList.get(1);              // return 3
</code></pre>
<p>Two ways of manipulating a linked list:</p>
<p><strong>1. Use the original linked list</strong> </p>
<p><strong>2. Setting a dummy head node</strong></p>
<p>The following is used to set a dummy head node (this is more convenient, as you can see by looking at the code)</p>
<h3 id="amp-C"><a href="#amp-C" class="headerlink" title="&amp;C++"></a>&amp;C++</h3><pre><code class="cpp">class MyLinkedList &#123;
public:
    // Define the linked list node structure
    struct LinkedNode &#123;
        int val;
        LinkedNode* next;
        LinkedNode(int val):val(val), next(nullptr)&#123;&#125;
    &#125;;

    // Initialise a linked list
    MyLinkedList() &#123;
        _dummyHead = new LinkedNode(0); // a dummy node
        _size = 0;
    &#125;

    // Get the value of the index node, return -1 if index is illegal, note that index starts at 0 and the 0th node is the head node
    int get(int index) &#123;
        if (index &gt; (_size - 1) || index &lt; 0) &#123;
            return -1;
        &#125;
        LinkedNode* cur = _dummyHead-&gt;next;
        while(index--)&#123; // if--index we will fall into loop
            cur = cur-&gt;next;
        &#125;
        return cur-&gt;val;
    &#125;

    // Insert a node at the top of the linked list, and when the insertion is complete, the newly inserted node is the new head node of the linked list
    void addAtHead(int val) &#123;
        LinkedNode* newNode = new LinkedNode(val);
        newNode-&gt;next = _dummyHead-&gt;next;
        _dummyHead-&gt;next = newNode;
        _size++;
    &#125;

    // Add a node to the end of the list
    void addAtTail(int val) &#123;
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(cur-&gt;next != nullptr)&#123;
            cur = cur-&gt;next;
        &#125;
        cur-&gt;next = newNode;
        _size++;
    &#125;

  // A new node is inserted before the index node, e.g. if index is 0, then the new inserted node is the new head node of the chain.
    // If index is equal to the length of the list, then the newly inserted node is the end node of the list.
    // if index is greater than the length of the list, then return null
    // If index is less than 0, set to 0 as the new head node of the linked list.
    void addAtIndex(int index, int val) &#123;
        if (index &gt; _size || index &lt; 0) &#123;
            return;
        &#125;
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(index--) &#123;
            cur = cur-&gt;next;
        &#125;
        newNode-&gt;next = cur-&gt;next;
        cur-&gt;next = newNode;
        _size++;
    &#125;

    // Delete the index node, if the index is larrger than or equal to the length of the linked list, return directly, note that the index starts from 0
    void deleteAtIndex(int index) &#123;
        if (index &gt;= _size || index &lt; 0) &#123;
            return;
        &#125;
        LinkedNode* cur = _dummyHead;
        while(index--) &#123;
            cur = cur -&gt;next;
        &#125;
        LinkedNode* tmp = cur-&gt;next;
        cur-&gt;next = cur-&gt;next-&gt;next;
        delete tmp;
        _size--;
    &#125;

    // print linked list
    void printLinkedList() &#123;
        LinkedNode* cur = _dummyHead;
        while (cur-&gt;next != nullptr) &#123;
            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; &quot; &quot;;
            cur = cur-&gt;next;
        &#125;
        cout &lt;&lt; endl;
    &#125;
private:
    int _size;
    LinkedNode* _dummyHead;

&#125;;
</code></pre>
<h3 id="amp-C-1"><a href="#amp-C-1" class="headerlink" title="&amp;C"></a>&amp;C</h3><pre><code class="cpp">typedef struct &#123;
    int val;
    struct MyLinkedList* next;
&#125;MyLinkedList;

/** Initialize your data structure here. */

MyLinkedList* myLinkedListCreate() &#123;
    //a dummy node
    MyLinkedList* head = (MyLinkedList *)malloc(sizeof (MyLinkedList));
    head-&gt;next = NULL;
    return head;
&#125;

/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
int myLinkedListGet(MyLinkedList* obj, int index) &#123;
    MyLinkedList *cur = obj-&gt;next;
    for (int i = 0; cur != NULL; i++)&#123;
        if (i == index)&#123;
            return cur-&gt;val;
        &#125;
        else&#123;
            cur = cur-&gt;next;
        &#125;
    &#125;
    return -1;
&#125;

/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
void myLinkedListAddAtHead(MyLinkedList* obj, int val) &#123;
    MyLinkedList *nhead = (MyLinkedList *)malloc(sizeof (MyLinkedList));
    nhead-&gt;val = val;
    nhead-&gt;next = obj-&gt;next;
    obj-&gt;next = nhead;

&#125;

/** Append a node of value val to the last element of the linked list. */
void myLinkedListAddAtTail(MyLinkedList* obj, int val) &#123;
    MyLinkedList *cur = obj;
    while(cur-&gt;next != NULL)&#123;
        cur = cur-&gt;next;
    &#125;
    MyLinkedList *ntail = (MyLinkedList *)malloc(sizeof (MyLinkedList));
    ntail-&gt;val = val;
    ntail-&gt;next = NULL;
    cur-&gt;next = ntail;
&#125;

/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) &#123;
    if (index == 0)&#123;
        myLinkedListAddAtHead(obj, val);
        return;
    &#125;
    MyLinkedList *cur = obj-&gt;next;
    for (int i = 1 ;cur != NULL; i++)&#123;
        if (i == index)&#123;
            MyLinkedList* newnode = (MyLinkedList *)malloc(sizeof (MyLinkedList));
            newnode-&gt;val = val;
            newnode-&gt;next = cur-&gt;next;
            cur-&gt;next = newnode;
            return;
        &#125;
        else&#123;
            cur = cur-&gt;next;
        &#125;
    &#125;
&#125;

/** Delete the index-th node in the linked list, if the index is valid. */
void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) &#123;
    if (index == 0)&#123;
        MyLinkedList *tmp = obj-&gt;next;
        if (tmp != NULL)&#123;
            obj-&gt;next = tmp-&gt;next;
            free(tmp)     
        &#125;
        return;
    &#125;
    MyLinkedList *cur = obj-&gt;next;
    for (int i = 1 ;cur != NULL &amp;&amp; cur-&gt;next != NULL; i++)&#123;
        if (i == index)&#123;
            MyLinkedList *tmp = cur-&gt;next;
            if (tmp != NULL) &#123;
                cur-&gt;next = tmp-&gt;next;
                free(tmp);
            &#125;
            return;
        &#125;
        else&#123;
            cur = cur-&gt;next;
        &#125;
    &#125;
    
&#125;

void myLinkedListFree(MyLinkedList* obj) &#123;
    while(obj != NULL)&#123;
        MyLinkedList *tmp = obj;
        obj = obj-&gt;next;
        free(tmp);
    &#125;
&#125;

/**
 * Your MyLinkedList struct will be instantiated and called as such:
 * MyLinkedList* obj = myLinkedListCreate();
 * int param_1 = myLinkedListGet(obj, index);
 
 * myLinkedListAddAtHead(obj, val);
 
 * myLinkedListAddAtTail(obj, val);
 
 * myLinkedListAddAtIndex(obj, index, val);
 
 * myLinkedListDeleteAtIndex(obj, index);
 
 * myLinkedListFree(obj);
*/
</code></pre>
<h3 id="amp-Java"><a href="#amp-Java" class="headerlink" title="&amp;Java"></a>&amp;Java</h3><pre><code class="cpp">//single linked list 
class ListNode &#123;
    int val;
    ListNode next;
    ListNode()&#123;&#125;
    ListNode(int val) &#123;
        this.val=val;
    &#125;
&#125;
class MyLinkedList &#123;
    //size of this linked list
    int size;
    //dummy node
    ListNode head;

    //initialise linked list
    public MyLinkedList() &#123;
        size = 0;
        head = new ListNode(0);
    &#125;

    //get the value of index node 
    public int get(int index) &#123;
        //if index is illgel return -1
        if (index &lt; 0 || index &gt;= size) &#123;
            return -1;
        &#125;
        ListNode currentNode = head;
        // the list contains a dummy node, so we find the node of  index+1 
        for (int i = 0; i &lt;= index; i++) &#123;
            currentNode = currentNode.next;
        &#125;
        return currentNode.val;
    &#125;

    //Insert a node at the top of the list
    public void addAtHead(int val) &#123;
        addAtIndex(0, val);
    &#125;

    //Insert a node at the end of the list
    public void addAtTail(int val) &#123;
        addAtIndex(size, val);
    &#125;

    // Insert a new node before the index node, e.g. if index is 0, then the newly inserted node is the new head node of the list.
    // If index is equal to the length of the list, then the newly inserted node is the end node of the list
    // If index is larger than the length of the list, then return null
    
    public void addAtIndex(int index, int val) &#123;
        if (index &gt; size) &#123;
            return;
        &#125;
        if (index &lt; 0) &#123;
            index = 0;
        &#125;
        size++;
        
        //find the fronter of the inserted node
        ListNode pred = head;
        for (int i = 0; i &lt; index; i++) &#123;
            pred = pred.next;
        &#125;
        ListNode toAdd = new ListNode(val);
        toAdd.next = pred.next;
        pred.next = toAdd;
    &#125;

    //detele the node of index
    public void deleteAtIndex(int index) &#123;
        if (index &lt; 0 || index &gt;= size) &#123;
            return;
        &#125;
        size--;
        if (index == 0) &#123;
            head = head.next;
        return;
        &#125;
        ListNode pred = head;
        for (int i = 0; i &lt; index ; i++) &#123;
            pred = pred.next;
        &#125;
        pred.next = pred.next.next;
    &#125;
&#125;


/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-11-28T00:00:00.000Z" title="28/11/2021, 00:00:00">2021-11-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-05T22:22:55.235Z" title="05/10/2022, 23:22:55">2022-10-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">4 minutes read (About 639 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/11/28/RemoveLinkedListElements/">Remove Linked List Elements</a></h1><div class="content"><p>Given the head of a <strong>linked list</strong> and an integer val, <strong>remove</strong> all the nodes of the linked list that has Node.val &#x3D;&#x3D; val, and return the <strong>new head</strong>.</p>
<pre><code class="cpp">Example1:
Input: head = [1,2,6,3,4,5,6], val = 6
Output: [1,2,3,4,5]
</code></pre>
<pre><code class="cpp">Example2:
Input: head = [7,7,7,7], val = 7
Output: []
</code></pre>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><ul>
<li>If we use C, after deleting the target node, we also need to delete the original memory of the deleted node</li>
<li>If we use Java or Python we don’t need to manage memory manually</li>
</ul>
<p>The following two ways of manipulating a linked list are involved here.</p>
<ol>
<li><p>Using the original linked list </p>
</li>
<li><p>Set a dummy head node</p>
</li>
</ol>
<h3 id="1-Using-the-original-linked-list"><a href="#1-Using-the-original-linked-list" class="headerlink" title="1. Using the original linked list"></a>1. Using the original linked list</h3><p><img src="/2021/11/28/RemoveLinkedListElements/remove1.jpg" alt="Remove element 1"><br>Removing the head node is not the same as removing other nodes, as the other nodes in the chain are removed from the current node by the previous node, whereas the head node does not have a previous node.</p>
<p>So how do you remove the head node? In fact, all you have to do is move the head node back one position, which removes a head node from the chain.<br><img src="/2021/11/28/RemoveLinkedListElements/remove2.jpg" alt="Step1: Remove element 1"></p>
<p>Don’t forget to delete the original head node from memory.<br><img src="/2021/11/28/RemoveLinkedListElements/remove3.jpg" alt="Step2: Remove element 1"></p>
<h3 id="2-Set-a-dummy-head-node"><a href="#2-Set-a-dummy-head-node" class="headerlink" title="2. Set a dummy head node"></a>2. Set a dummy head node</h3><p>Removing the head node in a single linked list is not the same as removing other nodes, so could there be a uniform logic for removing nodes in a linked list?</p>
<p>It is actually possible to set up a dummy head node so that all nodes of the original chain list can be removed in a uniform manner.<br><img src="/2021/11/28/RemoveLinkedListElements/remove4.jpg" alt="Remove element 1 by seting dummy node"><br>To show how to set up a dummy head node. we are still in this linked list, remove element 1.<br>Here’s how to add a dummy head node as a new head node to the linked list, removing this old head node element 1 at this point.</p>
<p><em><strong>&amp;C</strong></em></p>
<pre><code class="cpp">#Type1: Use Original Linked list

class Solution &#123;
public:
    ListNode* removeElements(ListNode* head, int val) &#123;
        // delete head node
        while (head != NULL &amp;&amp; head-&gt;val == val) &#123; // NOtice:not if here
            ListNode* tmp = head;
            head = head-&gt;next;
            delete tmp;
        &#125;

        // delete non-head node
        ListNode* cur = head;
        while (cur != NULL &amp;&amp; cur-&gt;next!= NULL) &#123;
            if (cur-&gt;next-&gt;val == val) &#123;
                ListNode* tmp = cur-&gt;next;
                cur-&gt;next = cur-&gt;next-&gt;next;
                delete tmp;
            &#125; else &#123;
                cur = cur-&gt;next;
            &#125;
        &#125;
        return head;
    &#125;
&#125;;
</code></pre>
<pre><code class="cpp">#Type2: Set a dummy head node

class Solution &#123;
public:
    ListNode* removeElements(ListNode* head, int val) &#123;
        ListNode* dummyHead = new ListNode(0); // Set a dummy head node
        dummyHead-&gt;next = head; // let the dummy head node point to head so that we can delete target later
        ListNode* cur = dummyHead;
        while (cur-&gt;next != NULL) &#123;
            if(cur-&gt;next-&gt;val == val) &#123;
                ListNode* tmp = cur-&gt;next;
                cur-&gt;next = cur-&gt;next-&gt;next;
                delete tmp;
            &#125; else &#123;
                cur = cur-&gt;next;
            &#125;
        &#125;
        head = dummyHead-&gt;next;
        delete dummyHead;
        return head;
    &#125;
&#125;;
</code></pre>
<p><em><strong>&amp;Java</strong></em></p>
<pre><code class="cpp">#Type1: set dummy node

public ListNode removeElements(ListNode head, int val) &#123;
    if (head == null) &#123;
        return head;
    &#125;
    // since the delete operation refers to head node, so we set a dummy node
    ListNode dummy = new ListNode(-1, head);
    ListNode pre = dummy;
    ListNode cur = head;
    while (cur != null) &#123;
        if (cur.val == val) &#123;
            pre.next = cur.next;
        &#125; else &#123;
            pre = cur;
        &#125;
        cur = cur.next;
    &#125;
    return dummy.next;
&#125;
</code></pre>
<pre><code class="cpp">#Type2: set a pre node

public ListNode removeElements(ListNode head, int val) &#123;
    while (head != null &amp;&amp; head.val == val) &#123;
        head = head.next;
    &#125;
    if (head == null) &#123;
        return head;
    &#125;
   
    ListNode pre = head;
    ListNode cur = head.next;
    while (cur != null) &#123;
        if (cur.val == val) &#123;
            pre.next = cur.next;
        &#125; else &#123;
            pre = cur;
        &#125;
        cur = cur.next;
    &#125;
    return head;
&#125;
</code></pre>
<pre><code class="cpp">#Type3: Do not set a dummy node or pre node

public ListNode removeElements(ListNode head, int val) &#123;
    while(head!=null &amp;&amp; head.val==val)&#123;
        head = head.next;
    &#125;
    ListNode curr = head;
    while(curr!=null)&#123;
        while(curr.next!=null &amp;&amp; curr.next.val == val)&#123;
            curr.next = curr.next.next;
        &#125;
        curr = curr.next;
    &#125;
    return head;
&#125;
</code></pre>
<p><strong>Time Complexity: O(n)</strong><br><strong>Space Complexty: O(1)</strong></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/tags/C-C/">Previous</a></div><div class="pagination-next"><a href="/tags/C-C/page/3/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/tags/C-C/">1</a></li><li><a class="pagination-link is-current" href="/tags/C-C/page/2/">2</a></li><li><a class="pagination-link" href="/tags/C-C/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Your name"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Your name</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">24</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Category</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">17</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-09-29T23:00:00.000Z">2022-09-30</time></p><p class="title"><a href="/2022/09/30/LetterCombinationsofaPhoneNumber/">Letter Combinations of a Phone Number</a></p><p class="categories"><a href="/categories/Algorithm/">Algorithm</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-09-14T23:00:00.000Z">2022-09-15</time></p><p class="title"><a href="/2022/09/15/Combinations-Pruning/">Combinations-Pruning</a></p><p class="categories"><a href="/categories/Algorithm/">Algorithm</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-08-30T23:00:00.000Z">2022-08-31</time></p><p class="title"><a href="/2022/08/31/BackTracking-Combinations/">BackTracking-Combinations</a></p><p class="categories"><a href="/categories/Algorithm/">Algorithm</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-08-14T23:00:00.000Z">2022-08-15</time></p><p class="title"><a href="/2022/08/15/BackTrackingAlgorithmBasic/">BackTracking Algorithm Basic</a></p><p class="categories"><a href="/categories/Algorithm/">Algorithm</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-30T23:00:00.000Z">2022-07-31</time></p><p class="title"><a href="/2022/07/31/ConvertSortedArraytoBinarySearchTree/">Convert Sorted Array to Binary Search Tree</a></p><p class="categories"><a href="/categories/Algorithm/">Algorithm</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/09/"><span class="level-start"><span class="level-item">September 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/08/"><span class="level-start"><span class="level-item">August 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">July 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">June 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">October 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Array/"><span class="tag">Array</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BackTracking/"><span class="tag">BackTracking</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BinarySearchTree/"><span class="tag">BinarySearchTree</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BinaryTree/"><span class="tag">BinaryTree</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-C/"><span class="tag">C/C++</span><span class="tag">23</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Combination/"><span class="tag">Combination</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DoublePointers/"><span class="tag">DoublePointers</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Iteration/"><span class="tag">Iteration</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LinkedList/"><span class="tag">LinkedList</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linkedlist/"><span class="tag">Linkedlist</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Pruning/"><span class="tag">Pruning</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Resursion/"><span class="tag">Resursion</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/String/"><span class="tag">String</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TraversalOfBinaryTree/"><span class="tag">TraversalOfBinaryTree</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/loop-invariant/"><span class="tag">loop invariant</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2023 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>