<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":{"text":"Tianhao'Site"}}},"description":""}</script><link rel="icon" href="/img/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="jasmine"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="jasmine"></script><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Tianhao&#039;Site</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-01-30T00:00:00.000Z" title="30/01/2022, 00:00:00">2022-01-30</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">2 minutes read (About 278 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/01/30/ReverseString/">Reverse String</a></h1><div class="content"><h3 id="TEST-YOURSELF"><a href="#TEST-YOURSELF" class="headerlink" title="TEST YOURSELF"></a>TEST YOURSELF</h3><p>Write a function that <strong>reverses a string</strong>. The input string is given as an array of characters s.</p>
<p>You must do this by modifying the input array in-place with O(1) extra memory.</p>
<pre><code class="cpp">Example 1:

Input: s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]
</code></pre>
<pre><code class="cpp">Example 2:

Input: s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]
Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]
</code></pre>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>In inverting a linked list, the <strong>double pointer method</strong> is used.</p>
<p>Inverting strings is still done using the double pointer method, except that it is actually <strong>simpler</strong> to invert strings than list.</p>
<p>Since strings are also arrays, the elements are <strong>distributed continuously in memory</strong>, which makes the difference between inverting a chain table and inverting a string.</p>
<p>For strings, we define two pointers (or index subscripts), one from the front of the string and one from the back of the string, and both pointers move towards the middle at the same time and swap elements.</p>
<p>Using the string <em><strong>hello</strong></em> as an example, the procedure is as follows:</p>
<p><img src="/2022/01/30/ReverseString/rever1.jpg" alt="Reverse &quot;hello&quot;1"></p>
<p><img src="/2022/01/30/ReverseString/rever2.jpg" alt="Reverse &quot;hello&quot;2"></p>
<p><img src="/2022/01/30/ReverseString/rever3.jpg" alt="Reverse &quot;hello&quot;3"></p>
<h3 id="amp-C"><a href="#amp-C" class="headerlink" title="&amp;C++"></a>&amp;C++</h3><pre><code class="cpp">void reverseString(vector&lt;char&gt;&amp; s) &#123;
    for (int i = 0, j = s.size() - 1; i &lt; s.size()/2; i++, j--) &#123;
        swap(s[i],s[j]);
    &#125;
&#125;
</code></pre>
<h3 id="amp-Java"><a href="#amp-Java" class="headerlink" title="&amp;Java"></a>&amp;Java</h3><pre><code class="cpp">class Solution &#123;
    public void reverseString(char[] s) &#123;
        int l = 0;
        int r = s.length - 1;
        while (l &lt; r) &#123;
            s[l] ^= s[r];  
            s[r] ^= s[l];             
             s[l] ^= s[r];              
             l++;
#              r--;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="amp-Python"><a href="#amp-Python" class="headerlink" title="&amp;Python"></a>&amp;Python</h3><pre><code class="cpp">
class Solution:
    def reverseString(self, s: List[str]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify s in-place instead.
        &quot;&quot;&quot;
        left, right = 0, len(s) - 1
        while left &lt; right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-01-11T00:00:00.000Z" title="11/01/2022, 00:00:00">2022-01-11</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">7 minutes read (About 1044 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/01/11/LinkedListCycle/">Linked List Cycle</a></h1><div class="content"><p>Given the <em><strong>head</strong></em> of a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.</p>
<p>Do not modify the linked list.</p>
<pre><code class="cpp">Example 1:

Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the second node.
</code></pre>
<p><img src="/2022/01/11/LinkedListCycle/example1.jpg" alt="Example1"></p>
<pre><code class="cpp">Example 2:

Input: head = [1,2], pos = 0
Output: tail connects to node index 0
Explanation: There is a cycle in the linked list, where tail connects to the first node.
</code></pre>
<p><img src="/2022/01/11/LinkedListCycle/example2.jpg" alt="Example2"></p>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>There are two main breakthrough points.</p>
<ul>
<li>Determining whether there is a ring in this linked list </li>
<li>If there is a ring, how to find the entrance to the ring</li>
</ul>
<h3 id="1-Determining-whether-there-is-a-ring-in-this-linked-list"><a href="#1-Determining-whether-there-is-a-ring-in-this-linked-list" class="headerlink" title="1. Determining whether there is a ring in this linked list"></a>1. Determining whether there is a ring in this linked list</h3><ol>
<li>We can use the <strong>fast and slow pointer method</strong> to define fast and slow pointers respectively, starting from the head node, the fast pointer <em><strong>moves two nodes</strong></em> at a time, the slow pointer <em><strong>moves one node</strong></em> at a time, if the fast and slow pointers <strong>meet</strong> on the way, it means that the list has a ring.</li>
</ol>
<ul>
<li>Why does the fast pointer move two nodes and the slow pointer move one node and if there is a ring, they must meet inside the ring, instead of always being <strong>staggered</strong>?</li>
</ul>
<p> First of all,  the fast pointer must enter the ring first. If the fast pointer and the slow pointer meet, <strong>they must meet in the ring</strong>, there is no doubt about that.</p>
<ul>
<li><p>So let’s see, why must the fast pointer and the slow pointer meet?</p>
<p>We can <strong>draw</strong> a ring and have the fast pointer start to catch up with the slow pointer at any one of the nodes.</p>
</li>
</ul>
<p> We will find that this is what happens in the end, as follows:</p>
<p><img src="/2022/01/11/LinkedListCycle/cycle1.jpg" alt="fast_slow pointers"></p>
<p>fast and slow each take one more step, and fast and slow meet</p>
<p>This is because fast takes two steps and slow takes one step. In fact, compared to slow, fast is approaching slow node by node, so fast must be able to overlap with slow.</p>
<p><img src="/2022/01/11/LinkedListCycle/cycle2.jpg" alt="fast_slow pointers move"></p>
<p><img src="/2022/01/11/LinkedListCycle/cycle3.jpg" alt="fast_slow pointers encounter"></p>
<h3 id="2-If-there-is-a-ring-how-to-find-the-entrance-to-the-ring"><a href="#2-If-there-is-a-ring-how-to-find-the-entrance-to-the-ring" class="headerlink" title="2. If there is a ring, how to find the entrance to the ring"></a>2. If there is a ring, how to find the entrance to the ring</h3><p>Assume that the number of nodes from the head node to the ring entry node is <strong>x</strong>. The number of nodes from the ring entry node to the node where the fast pointer meets the slow pointer is <strong>y</strong>. The number of nodes from the meeting node to the ring entry node is <strong>z</strong>. As shown in the figure.</p>
<p><img src="/2022/01/11/LinkedListCycle/cycle4.jpg" alt="fast_slow circular"></p>
<p>Then when the fast pointer and slow pointer meet: the number of nodes walked by the slow pointer is: <strong>x + y</strong>, the number of nodes walked by the fast pointer is: <strong>x + y + n (y + z)</strong>, n is the number of n turns in the ring before the fast pointer meets the slow pointer, and <strong>(y + z)</strong> is the number of nodes in a turn A.</p>
<p>Since the fast pointer takes two nodes in one step and the slow pointer takes one node in one step, the number of nodes taken by the fast pointer &#x3D; the number of nodes taken by the slow pointer * 2:</p>
<p><strong>(x + y) * 2 &#x3D; x + y + n (y + z)</strong></p>
<p>eliminating one <strong>(x + y)</strong> on both sides: <strong>x + y &#x3D; n (y + z)</strong></p>
<p>Since the entrance to the ring is to be found, then x is required because <strong>x</strong> represents the distance from the head node to the entrance node of the ring.</p>
<p>So put <strong>x</strong> alone on the left: <strong>x &#x3D; n (y + z) - y</strong> ,</p>
<p>Then from <strong>n(y + z)</strong>, we can put a <strong>(y + z)</strong>, and after sorting out the formula, we have the following formula: <strong>x &#x3D; (n - 1) (y + z) + z</strong>. <em><strong>Note that n must be larger than or equal to 1 here</strong></em>, because the fast pointer must move at least one more turn to meet the slow pointer.</p>
<h3 id="What-does-this-formula-show"><a href="#What-does-this-formula-show" class="headerlink" title="What does this formula show?"></a>What does this formula show?</h3><ul>
<li>where <strong>n is 1</strong>. This means that the fast pointer encounters the slow pointer after one turn in the loop.</li>
</ul>
<p>When n is 1, the formula resolves to <strong>x &#x3D; z</strong></p>
<p>This means that one pointer from the head node and one pointer from the meeting node, both of which go one node at a time, will be the node at the entrance to the ring when they meet.</p>
<p>This means that at the meeting node, a pointer index1 is defined, and at the head node, a pointer index2 is defined.</p>
<p>Let index1 and index2 move simultaneously, one node at a time, so that where they meet is the node at the entrance to the ring.</p>
<ul>
<li>where <strong>n is larger than 1</strong>, the fast pointer turns <em><strong>n times</strong></em> in the ring before encountering the slow pointer.</li>
</ul>
<p>In fact, the effect is the same as when n is 1. You can find the entrance node of the ring by this method, except that the index1 pointer takes an extra <strong>(n-1)</strong> turns in the ring and then meets index2, which is still the entrance node of the ring</p>
<h3 id="amp-C"><a href="#amp-C" class="headerlink" title="&amp;C++"></a>&amp;C++</h3><pre><code class="cpp">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode *detectCycle(ListNode *head) &#123;
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
               // exsit a ring
            if (slow == fast) &#123;
                ListNode* index1 = fast;
                ListNode* index2 = head;
                while (index1 != index2) &#123;
                    index1 = index1-&gt;next;
                    index2 = index2-&gt;next;
                &#125;
                return index2; // return the entrance of ring
            &#125;
        &#125;
        return NULL;
    &#125;
&#125;;
</code></pre>
<h3 id="amp-Java"><a href="#amp-Java" class="headerlink" title="&amp;Java"></a>&amp;Java</h3><pre><code class="cpp">public class Solution &#123;
    public ListNode detectCycle(ListNode head) &#123;
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null &amp;&amp; fast.next != null) &#123;
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) &#123;// exsit a ring
                ListNode index1 = fast;
                ListNode index2 = head;
                // the encounter nodeis the entrance of ring
                while (index1 != index2) &#123;
                    index1 = index1.next;
                    index2 = index2.next;
                &#125;
                return index1;
            &#125;
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-28T00:00:00.000Z" title="28/12/2021, 00:00:00">2021-12-28</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">4 minutes read (About 640 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/28/ReverseLinkedList/">Reverse Linked List</a></h1><div class="content"><p>Given the <strong>head</strong> of a singly linked list, reverse the list, and return the <em>reversed list</em>.</p>
<pre><code class="cpp">Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
</code></pre>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>It would actually be a waste of memory space to define a new chain table and implement the inversion of the elements of the chain table.</p>
<p>In fact, you only need to change the pointing of the next pointer of the chain table to invert it directly without redefining a new chain table, as shown in the figure:<br>    <img src="/2021/12/28/ReverseLinkedList/reverse1.jpg" alt="Reverse a linked list"></p>
<p>Previously the head node of the chain was element 1, after reversing it the head node is element 5, no nodes are added or removed here, just the direction of the next pointer.</p>
<p><strong>Reverse flow:</strong></p>
<ol>
<li><p>Firstly, define a cur pointer to the head node, and a pre pointer, initialized to null.</p>
</li>
<li><p>Then it’s time to reverse the process, first by saving the cur-&gt;next node with the tmp pointer, that is, by saving this node.</p>
</li>
<li><p>Why save this node?  Because the next step is to change the cur-&gt;next pointer, so that cur-&gt;next points to pre, which has already reversed the first node.</p>
</li>
<li><p>The next step is to loop through the following code logic, continuing to move the pre and cur pointers.</p>
</li>
<li><p>Finally, the cur pointer is pointing to null, the loop is over and the chain is reversed. At this point we return the pre pointer and the pre pointer points to the new head node.</p>
</li>
</ol>
<h3 id="amp-C"><a href="#amp-C" class="headerlink" title="&amp;C++"></a>&amp;C++</h3><p><strong>1.Double Pointer</strong></p>
<pre><code class="cpp">
class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        ListNode* temp; // 保存cur的下一个节点
        ListNode* cur = head;
        ListNode* pre = NULL;
        while(cur) &#123;
            temp = cur-&gt;next;  // 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next
            cur-&gt;next = pre; // 翻转操作
            // 更新pre 和 cur指针
            pre = cur;
            cur = temp;
        &#125;
        return pre;
    &#125;
&#125;;
</code></pre>
<p><strong>2.Recursion</strong></p>
<pre><code class="cpp">
public:
    ListNode* reverse(ListNode* pre,ListNode* cur)&#123;
        if(cur == NULL) return pre;
        ListNode* temp = cur-&gt;next;
        cur-&gt;next = pre;
        // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步
        // pre = cur;
        // cur = temp;
        return reverse(cur,temp);
    &#125;
    ListNode* reverseList(ListNode* head) &#123;
        // 和双指针法初始化是一样的逻辑
        // ListNode* cur = head;
        // ListNode* pre = NULL;
        return reverse(NULL, head);
    &#125;

&#125;;
</code></pre>
<h3 id="amp-Java"><a href="#amp-Java" class="headerlink" title="&amp;Java"></a>&amp;Java</h3><p><strong>1.Double Pointer</strong></p>
<pre><code class="cpp">
class Solution &#123;
    public ListNode reverseList(ListNode head) &#123;
        ListNode prev = null;
        ListNode cur = head;
        ListNode temp = null;
        while (cur != null) &#123;
            temp = cur.next;// 保存下一个节点
            cur.next = prev;
            prev = cur;
            cur = temp;
        &#125;
        return prev;
    &#125;
&#125;
</code></pre>
<p><strong>2.Recursion</strong></p>
<pre><code class="cpp">
class Solution &#123;
    public ListNode reverseList(ListNode head) &#123;
        return reverse(null, head);
    &#125;

    private ListNode reverse(ListNode prev, ListNode cur) &#123;
        if (cur == null) &#123;
            return prev;
        &#125;
        ListNode temp = null;
        temp = cur.next;// 先保存下一个节点
        cur.next = prev;// 反转
        // 更新prev、cur位置
        // prev = cur;
        // cur = temp;
        return reverse(cur, temp);
    &#125;
&#125;
</code></pre>
<h3 id="amp-Python"><a href="#amp-Python" class="headerlink" title="&amp;Python"></a>&amp;Python</h3><p><strong>1.Double Pointer</strong></p>
<pre><code class="cpp">
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        cur = head   
        pre = None
        while(cur!=None):
            temp = cur.next # 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next
            cur.next = pre #反转
            #更新pre、cur指针
            pre = cur
            cur = temp
        return pre
</code></pre>
<p><strong>2.Recursion</strong></p>
<pre><code class="cpp">
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        
        def reverse(pre,cur):
            if not cur:
                return pre
                
            tmp = cur.next
            cur.next = pre

            return reverse(cur,tmp)
        
        return reverse(None,head)
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-28T00:00:00.000Z" title="28/12/2021, 00:00:00">2021-12-28</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">2 minutes read (About 335 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/28/SwapNodesinPairs/">Swap Nodes in Pairs</a></h1><div class="content"><p>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.)</p></div><a class="article-more button is-small is-size-7" href="/2021/12/28/SwapNodesinPairs/#more">Read more</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2021/12/09/DesignLinkedList/"><img class="fill" src="/gallery/covers/cover.jpg" alt="Design Linked List"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-09T00:00:00.000Z" title="09/12/2021, 00:00:00">2021-12-09</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">9 minutes read (About 1275 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/09/DesignLinkedList/">Design Linked List</a></h1><div class="content"><p>Implement the MyLinkedList class:</p>
<ul>
<li><p><em><strong>int get(int index)</strong></em> Get the value of the indexth node in the linked list. If the index is invalid, return -1.</p>
</li>
<li><p><em><strong>void addAtHead(int val)</strong></em> Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</p>
</li>
<li><p><em><strong>void addAtTail(int val)</strong></em>  Append a node of value val as the last element of the linked list.</p>
</li>
<li><p><em><strong>void addAtIndex(int index, int val)</strong></em> Add a node of value val before the indexth node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted.</p>
</li>
<li><p><strong>void deleteAtIndex(int index</strong>) Delete the indexth node in the linked list, if the index is valid.</p>
</li>
</ul>
<pre><code class="cpp">Example:

Input
[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]
[[], [1], [3], [1, 2], [1], [1], [1]]
Output
[null, null, null, null, 2, null, 3]

Explanation
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // linked list becomes 1-&gt;2-&gt;3
myLinkedList.get(1);              // return 2
myLinkedList.deleteAtIndex(1);    // now the linked list is 1-&gt;3
myLinkedList.get(1);              // return 3
</code></pre>
<p>Two ways of manipulating a linked list:</p>
<p><strong>1. Use the original linked list</strong> </p>
<p><strong>2. Setting a dummy head node</strong></p>
<p>The following is used to set a dummy head node (this is more convenient, as you can see by looking at the code)</p>
<h3 id="amp-C"><a href="#amp-C" class="headerlink" title="&amp;C++"></a>&amp;C++</h3><pre><code class="cpp">class MyLinkedList &#123;
public:
    // Define the linked list node structure
    struct LinkedNode &#123;
        int val;
        LinkedNode* next;
        LinkedNode(int val):val(val), next(nullptr)&#123;&#125;
    &#125;;

    // Initialise a linked list
    MyLinkedList() &#123;
        _dummyHead = new LinkedNode(0); // a dummy node
        _size = 0;
    &#125;

    // Get the value of the index node, return -1 if index is illegal, note that index starts at 0 and the 0th node is the head node
    int get(int index) &#123;
        if (index &gt; (_size - 1) || index &lt; 0) &#123;
            return -1;
        &#125;
        LinkedNode* cur = _dummyHead-&gt;next;
        while(index--)&#123; // if--index we will fall into loop
            cur = cur-&gt;next;
        &#125;
        return cur-&gt;val;
    &#125;

    // Insert a node at the top of the linked list, and when the insertion is complete, the newly inserted node is the new head node of the linked list
    void addAtHead(int val) &#123;
        LinkedNode* newNode = new LinkedNode(val);
        newNode-&gt;next = _dummyHead-&gt;next;
        _dummyHead-&gt;next = newNode;
        _size++;
    &#125;

    // Add a node to the end of the list
    void addAtTail(int val) &#123;
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(cur-&gt;next != nullptr)&#123;
            cur = cur-&gt;next;
        &#125;
        cur-&gt;next = newNode;
        _size++;
    &#125;

  // A new node is inserted before the index node, e.g. if index is 0, then the new inserted node is the new head node of the chain.
    // If index is equal to the length of the list, then the newly inserted node is the end node of the list.
    // if index is greater than the length of the list, then return null
    // If index is less than 0, set to 0 as the new head node of the linked list.
    void addAtIndex(int index, int val) &#123;
        if (index &gt; _size || index &lt; 0) &#123;
            return;
        &#125;
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(index--) &#123;
            cur = cur-&gt;next;
        &#125;
        newNode-&gt;next = cur-&gt;next;
        cur-&gt;next = newNode;
        _size++;
    &#125;

    // Delete the index node, if the index is larrger than or equal to the length of the linked list, return directly, note that the index starts from 0
    void deleteAtIndex(int index) &#123;
        if (index &gt;= _size || index &lt; 0) &#123;
            return;
        &#125;
        LinkedNode* cur = _dummyHead;
        while(index--) &#123;
            cur = cur -&gt;next;
        &#125;
        LinkedNode* tmp = cur-&gt;next;
        cur-&gt;next = cur-&gt;next-&gt;next;
        delete tmp;
        _size--;
    &#125;

    // print linked list
    void printLinkedList() &#123;
        LinkedNode* cur = _dummyHead;
        while (cur-&gt;next != nullptr) &#123;
            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; &quot; &quot;;
            cur = cur-&gt;next;
        &#125;
        cout &lt;&lt; endl;
    &#125;
private:
    int _size;
    LinkedNode* _dummyHead;

&#125;;
</code></pre>
<h3 id="amp-C-1"><a href="#amp-C-1" class="headerlink" title="&amp;C"></a>&amp;C</h3><pre><code class="cpp">typedef struct &#123;
    int val;
    struct MyLinkedList* next;
&#125;MyLinkedList;

/** Initialize your data structure here. */

MyLinkedList* myLinkedListCreate() &#123;
    //a dummy node
    MyLinkedList* head = (MyLinkedList *)malloc(sizeof (MyLinkedList));
    head-&gt;next = NULL;
    return head;
&#125;

/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
int myLinkedListGet(MyLinkedList* obj, int index) &#123;
    MyLinkedList *cur = obj-&gt;next;
    for (int i = 0; cur != NULL; i++)&#123;
        if (i == index)&#123;
            return cur-&gt;val;
        &#125;
        else&#123;
            cur = cur-&gt;next;
        &#125;
    &#125;
    return -1;
&#125;

/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
void myLinkedListAddAtHead(MyLinkedList* obj, int val) &#123;
    MyLinkedList *nhead = (MyLinkedList *)malloc(sizeof (MyLinkedList));
    nhead-&gt;val = val;
    nhead-&gt;next = obj-&gt;next;
    obj-&gt;next = nhead;

&#125;

/** Append a node of value val to the last element of the linked list. */
void myLinkedListAddAtTail(MyLinkedList* obj, int val) &#123;
    MyLinkedList *cur = obj;
    while(cur-&gt;next != NULL)&#123;
        cur = cur-&gt;next;
    &#125;
    MyLinkedList *ntail = (MyLinkedList *)malloc(sizeof (MyLinkedList));
    ntail-&gt;val = val;
    ntail-&gt;next = NULL;
    cur-&gt;next = ntail;
&#125;

/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) &#123;
    if (index == 0)&#123;
        myLinkedListAddAtHead(obj, val);
        return;
    &#125;
    MyLinkedList *cur = obj-&gt;next;
    for (int i = 1 ;cur != NULL; i++)&#123;
        if (i == index)&#123;
            MyLinkedList* newnode = (MyLinkedList *)malloc(sizeof (MyLinkedList));
            newnode-&gt;val = val;
            newnode-&gt;next = cur-&gt;next;
            cur-&gt;next = newnode;
            return;
        &#125;
        else&#123;
            cur = cur-&gt;next;
        &#125;
    &#125;
&#125;

/** Delete the index-th node in the linked list, if the index is valid. */
void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) &#123;
    if (index == 0)&#123;
        MyLinkedList *tmp = obj-&gt;next;
        if (tmp != NULL)&#123;
            obj-&gt;next = tmp-&gt;next;
            free(tmp)     
        &#125;
        return;
    &#125;
    MyLinkedList *cur = obj-&gt;next;
    for (int i = 1 ;cur != NULL &amp;&amp; cur-&gt;next != NULL; i++)&#123;
        if (i == index)&#123;
            MyLinkedList *tmp = cur-&gt;next;
            if (tmp != NULL) &#123;
                cur-&gt;next = tmp-&gt;next;
                free(tmp);
            &#125;
            return;
        &#125;
        else&#123;
            cur = cur-&gt;next;
        &#125;
    &#125;
    
&#125;

void myLinkedListFree(MyLinkedList* obj) &#123;
    while(obj != NULL)&#123;
        MyLinkedList *tmp = obj;
        obj = obj-&gt;next;
        free(tmp);
    &#125;
&#125;

/**
 * Your MyLinkedList struct will be instantiated and called as such:
 * MyLinkedList* obj = myLinkedListCreate();
 * int param_1 = myLinkedListGet(obj, index);
 
 * myLinkedListAddAtHead(obj, val);
 
 * myLinkedListAddAtTail(obj, val);
 
 * myLinkedListAddAtIndex(obj, index, val);
 
 * myLinkedListDeleteAtIndex(obj, index);
 
 * myLinkedListFree(obj);
*/
</code></pre>
<h3 id="amp-Java"><a href="#amp-Java" class="headerlink" title="&amp;Java"></a>&amp;Java</h3><pre><code class="cpp">//single linked list 
class ListNode &#123;
    int val;
    ListNode next;
    ListNode()&#123;&#125;
    ListNode(int val) &#123;
        this.val=val;
    &#125;
&#125;
class MyLinkedList &#123;
    //size of this linked list
    int size;
    //dummy node
    ListNode head;

    //initialise linked list
    public MyLinkedList() &#123;
        size = 0;
        head = new ListNode(0);
    &#125;

    //get the value of index node 
    public int get(int index) &#123;
        //if index is illgel return -1
        if (index &lt; 0 || index &gt;= size) &#123;
            return -1;
        &#125;
        ListNode currentNode = head;
        // the list contains a dummy node, so we find the node of  index+1 
        for (int i = 0; i &lt;= index; i++) &#123;
            currentNode = currentNode.next;
        &#125;
        return currentNode.val;
    &#125;

    //Insert a node at the top of the list
    public void addAtHead(int val) &#123;
        addAtIndex(0, val);
    &#125;

    //Insert a node at the end of the list
    public void addAtTail(int val) &#123;
        addAtIndex(size, val);
    &#125;

    // Insert a new node before the index node, e.g. if index is 0, then the newly inserted node is the new head node of the list.
    // If index is equal to the length of the list, then the newly inserted node is the end node of the list
    // If index is larger than the length of the list, then return null
    
    public void addAtIndex(int index, int val) &#123;
        if (index &gt; size) &#123;
            return;
        &#125;
        if (index &lt; 0) &#123;
            index = 0;
        &#125;
        size++;
        
        //find the fronter of the inserted node
        ListNode pred = head;
        for (int i = 0; i &lt; index; i++) &#123;
            pred = pred.next;
        &#125;
        ListNode toAdd = new ListNode(val);
        toAdd.next = pred.next;
        pred.next = toAdd;
    &#125;

    //detele the node of index
    public void deleteAtIndex(int index) &#123;
        if (index &lt; 0 || index &gt;= size) &#123;
            return;
        &#125;
        size--;
        if (index == 0) &#123;
            head = head.next;
        return;
        &#125;
        ListNode pred = head;
        for (int i = 0; i &lt; index ; i++) &#123;
            pred = pred.next;
        &#125;
        pred.next = pred.next.next;
    &#125;
&#125;


/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
</code></pre>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/3/">Previous</a></div><div class="pagination-next"><a href="/page/5/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link is-current" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/categories/DeepLearning/"><span class="level-start"><span class="level-item">DeepLearning</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-14T23:00:00.000Z">2023-08-15</time></p><p class="title"><a href="/2023/08/15/Test/">TEST</a></p><p class="categories"><a href="/categories/DeepLearning/">DeepLearning</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-09-29T23:00:00.000Z">2022-09-30</time></p><p class="title"><a href="/2022/09/30/LetterCombinationsofaPhoneNumber/">Letter Combinations of a Phone Number</a></p><p class="categories"><a href="/categories/Algorithm/">Algorithm</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-09-14T23:00:00.000Z">2022-09-15</time></p><p class="title"><a href="/2022/09/15/Combinations-Pruning/">Combinations-Pruning</a></p><p class="categories"><a href="/categories/Algorithm/">Algorithm</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-08-14T23:00:00.000Z">2022-08-15</time></p><p class="title"><a href="/2022/08/15/BackTrackingAlgorithmBasic/">BackTracking Algorithm Basic</a></p><p class="categories"><a href="/categories/Algorithm/">Algorithm</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-30T23:00:00.000Z">2022-07-31</time></p><p class="title"><a href="/2022/07/31/ConvertSortedArraytoBinarySearchTree/">Convert Sorted Array to Binary Search Tree</a></p><p class="categories"><a href="/categories/Algorithm/">Algorithm</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Array/"><span class="tag">Array</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BackTracking/"><span class="tag">BackTracking</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BinarySearchTree/"><span class="tag">BinarySearchTree</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BinaryTree/"><span class="tag">BinaryTree</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-C/"><span class="tag">C/C++</span><span class="tag">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Combination/"><span class="tag">Combination</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DoublePointers/"><span class="tag">DoublePointers</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Iteration/"><span class="tag">Iteration</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LinkedList/"><span class="tag">LinkedList</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linkedlist/"><span class="tag">Linkedlist</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Optimazation/"><span class="tag">Optimazation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Pruning/"><span class="tag">Pruning</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Resursion/"><span class="tag">Resursion</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/String/"><span class="tag">String</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TraversalOfBinaryTree/"><span class="tag">TraversalOfBinaryTree</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/loop-invariant/"><span class="tag">loop invariant</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Tianhao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Tianhao</p><p class="is-size-6 is-block">a MATH and CS student</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Bristol, United Kingdom</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">24</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">18</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/jasminepp/jasminepp.github.io" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/jasminepp/jasminepp.github.io"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/08/"><span class="level-start"><span class="level-item">August 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/09/"><span class="level-start"><span class="level-item">September 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/08/"><span class="level-start"><span class="level-item">August 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">July 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">June 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">October 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Tianhao&#039;Site</a><p class="is-size-7"><span>&copy; 2023 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="jasmine"></script><script src="jasmine"></script><script src="jasmine" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>