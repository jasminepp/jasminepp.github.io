{"posts":[{"title":"BackTracking Algorithm Basic","text":"The Definition of Back Tracking Algorithm The BackTracking can also be called the backtracking search method, which is a way of searching. The Efficiency of Back Tracking AlgorithmBackTracking is not an efficient algorithm because backtracking is essentially an exhaustive process of enumerating all possibilities and selecting the answer we want. The Problems can be solved by Back Tracking AlgorithmThe BackTracking, in general, can solve the following kinds of problems: Combination problem: a set of k numbers inside N numbers is found according to certain rules Cutting problem: how many ways to cut a string according to certain rules Subset problem: how many eligible subsets are there in a set of N numbers Arrange problem: how many ways to arrange N numbers in full according to certain rules Checkerboard problem: N queens, solving sudoku, etc How to understand Back Tracking AlgorithmThe problems solved by BackTracking can all be abstracted into a tree structure.The size of the set constitutes the width of the tree, and the depth of the recursion constitutes the depth of the tree. It must be a tree of finite height (N-fork tree) since recursion must have a termination condition The Template Backtracking Backtracking function template return values and parameters The return value of a function in the backtracking algorithm is generally void. The backtracking function pseudo-code is as follows: 1void backtracking(parameter) Termination conditions for backtracking functions Since it is a tree structure, when traversing the tree structure we know that there must be a termination condition, so backtracking also has a termination condition. Generally speaking, if we find a leaf node and we have found an answer that satisfies the conditions, stored the answer, and ended the recursion at this level. So the backtracking function termination condition pseudo-code is as follows： 1234 if (termination condition) { save result; return;} Traversal process for backtracking search As we mentioned above, backtracking is generally a recursive search in sets, where the size of the set constitutes the width of the tree and the depth of the recursion constitutes the depth of the tree. As shown: The backtracking function traverses the following pseudo-code: 12345 for (select：the elements of this level set（the number of children of tree node == size of set）) { process node; backtracking(path, select table); // recursion backtracking, withdraw result} A for loop is a traversal of the set interval: the number of children of a node == the times of the for loop executes (horizontal traversal) Backtracking here calls itself and implements recursion. (vertical traversal) The backtracking algorithm template is as follows: 12345678910 void backtracking(parameter) { if (temination condition) { save result; return; } for (select：the elements of this level set（the number of children of tree node == size of set）) { process node; backtracking(path, select table); // recursion backtracking, withdraw result}","link":"/2022/08/15/BackTrackingAlgorithmBasic/"},{"title":"Binary Tree Basic","text":"What is Binary Tree Data Structure?Binary Tree is defined as a Tree data structure with at most 2 children. Since each element in a binary tree can have only 2 children, we typically name them the left and right child. The Type of Binary Trees1. Full Binary Tree k-ary tree: A (rooted) tree is k-ary if every node has at most k children. If k = 2 then the tree is called binary. A k ary tree is full if every internal node has exactly k children 2. Complete Binary Tree complete if all levels except possibly the last is entirely filled (and last level is filled from left to right) 3. Binary Search TreeThe trees described earlier have no values, while a binary search tree has values. A binary search tree is an ordered tree. if its left subtree is not empty, the values of all nodes in the left subtree are less than the value of its root node. if its right subtree is not empty, the values of all nodes in the right subtree are greater than the value of its root node. Its left and right subtrees are also each binary sorted trees The following two trees are both search trees: 4. Balanced Binary TreeBalanced Binary Tree：also known as an AVL (Adelson-Velsky and Landis) tree and has the following properties: it is an empty tree or the difference in height between its left and right subtrees does not exceed 1in absolute value both left and right subtrees are a balanced binary tree. as shown： The last one is not a balanced binary tree because the absolute value of the difference between the heights of its left and right subtrees exceeds 1. How binary trees are storedThere are two types of storage for binary trees. Linked storage(pointer) Sequential storage(array) Sequential storage has a continuous distribution of elements in memory, whereas linked storage has a series of nodes distributed at scattered addresses by means of pointers. How does using an array to store a binary tree traverse? If the parent node’s array subscript is i, then its left child is i * 2 + 1 and its right child is i * 2 + 2. Traversing Binary TreeThere are two main types of traversal of a binary tree. Depth-first traversal: go deeper first, then back when you encounter a leaf node. Pre-order traversal (recursive, iterative ) In-order traversal (recursive, iterative) Post-order traversal (recursive, iterative) Breadth-first traversal: go through layer by layer. Level Order traversal (iterative) The Definition of Binary Tree&amp;C++123456struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {}}; &amp;Java123456789101112public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; }} &amp;Python12345class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None","link":"/2022/03/28/BinaryTreeBasic/"},{"title":"Binary Search","text":"Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. 123Input: nums = [-1,0,3,5,9,12], target = 9Output: 4Explanation: 9 exists in nums and its index is 4 HINTThere are two pre-conditions for Binary Search here: The array is sorted in ascending order There are no duplicate elements in the array In addition, We also need to focus on the validity of the two ends of the range：[left, right] is according to while (left &lt;= right) or ***while (left &lt; right) *** The definition of an interval is an invariant, so insisting on bounds in a loop based on the definition of a lookup interval is the loop invariant rule C++ 12345678910111213141516171819202122//Type1:[left, right] class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int left = 0; int right = nums.size() - 1; // [left, right] while (left &lt;= right) { // when left==right，set[left, right] still works，so we use &lt;= int middle = left + ((right - left) / 2);// prevent override==(left + right)/2 if (nums[middle] &gt; target) { right = middle - 1; // target is in left set，so[left, middle - 1] } else if (nums[middle] &lt; target) { left = middle + 1; // target is in right set，so[middle + 1, right] } else { // nums[middle] == target return middle; // we find the target, return index } } // no target return -1; }}; Time Complexity : O(nlogn) 12345678910111213141516171819202122//Type2:[left, right) class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int left = 0; int right = nums.size() - 1; // [left, right) while (left &lt; right) { // when left==right，set[left, right] is meaningless，so we use &lt; int middle = left + ((right - left) / 2);// prevent override==(left + right)/2 if (nums[middle] &gt; target) { right = middle - 1; // target is in left set，so[left, middle) } else if (nums[middle] &lt; target) { left = middle + 1; // target is in right set，so[middle + 1, right) } else { // nums[middle] == target return middle; // we find the target, return index } } // no target return -1; }}; Java 12345678910111213141516171819class Solution { public int search(int[] nums, int target) { // To avoid multiple while loop when target is less than nums[0] nums[nums.length - 1] if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) { return -1; } int left = 0, right = nums.length - 1; while (left &lt;= right) { int mid = left + ((right - left) &gt;&gt; 1); if (nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else if (nums[mid] &gt; target) right = mid - 1; } return -1; }}","link":"/2021/10/02/BinarySearch/"},{"title":"Convert Sorted Array to Binary Search Tree","text":"TEST YOURSELFGiven an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one. Example 1: 123Input: nums = [-10,-3,0,5,9]Output: [0,-3,9,-10,null,5] Explanation: [0,-10,5,null,-3,null,9] is also accepted: HINTThe focus is on finding the split point, which is used as the current node, and then recursively the left interval and right interval. The split point is the node in the middle of the array. If the array is of even length and there are two intermediate nodes, which one is taken? Either one can be taken, except that it forms a different balanced binary search tree. Example: Input: [-10,-3,0,5,9] The following two trees, both of which are balanced binary search trees for this array, are as follows. If the length of the array to be partitioned is even and the middle element is two, the left element is tree 1 and the right element is tree 2 Recursion Determine the parameters and return value of the recursive function:We want to construct a binary tree, still using the return value of the recursive function to construct the left and right children of the middle node. Parameters: first the array is passed in, then the left subscript left and the right subscript right 12 // [left, right]TreeNode* traversal(vector&lt;int&gt;&amp; nums, int left, int right) Determine the termination condition: When the interval left &gt; right, the node is empty. 1if (left &gt; right) return nullptr; The logic for determining the single-level recursion: First take the position of the middle element of the array: int mid = left + ((right - left) / 2); Once the middle position is taken, start constructing nodes with the elements in the middle position: TreeNode* root = new TreeNode(nums[mid]); Then divide the interval, root’s left child picks up the next layer of left interval construction node, the right child picks up the next layer of right interval construction node. Finally, the root node is returned: 12345 int mid = left + ((right - left) / 2);TreeNode* root = new TreeNode(nums[mid]);root-&gt;left = traversal(nums, left, mid - 1);root-&gt;right = traversal(nums, mid + 1, right);return root; &amp;C++ 12345678910111213141516class Solution {private: TreeNode* traversal(vector&lt;int&gt;&amp; nums, int left, int right) { if (left &gt; right) return nullptr; int mid = left + ((right - left) / 2); TreeNode* root = new TreeNode(nums[mid]); root-&gt;left = traversal(nums, left, mid - 1); root-&gt;right = traversal(nums, mid + 1, right); return root; }public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) { TreeNode* root = traversal(nums, 0, nums.size() - 1); return root; }}; Iteration&amp;C++ 12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) return nullptr; TreeNode* root = new TreeNode(0); // initial root node queue&lt;TreeNode*&gt; nodeQue; // save traversal nodes queue&lt;int&gt; leftQue; // save left subscript queue&lt;int&gt; rightQue; // save right subscript nodeQue.push(root); // put root node in queue leftQue.push(0); // 0 is the initial position of left subscript rightQue.push(nums.size() - 1); // nums.size() - 1 is the initial position of right subscript while (!nodeQue.empty()) { TreeNode* curNode = nodeQue.front(); nodeQue.pop(); int left = leftQue.front(); leftQue.pop(); int right = rightQue.front(); rightQue.pop(); int mid = left + ((right - left) / 2); curNode-&gt;val = nums[mid]; // let middle node = mid value if (left &lt;= mid - 1) { // deal with left side curNode-&gt;left = new TreeNode(0); nodeQue.push(curNode-&gt;left); leftQue.push(left); rightQue.push(mid - 1); } if (right &gt;= mid + 1) { // deal with right side curNode-&gt;right = new TreeNode(0); nodeQue.push(curNode-&gt;right); leftQue.push(mid + 1); rightQue.push(right); } } return root; }}; &amp;JavaRecursion 1234567891011121314151617class Solution { public TreeNode sortedArrayToBST(int[] nums) { TreeNode root = traversal(nums, 0, nums.length - 1); return root; } // [left, right] private TreeNode traversal(int[] nums, int left, int right) { if (left &gt; right) return null; int mid = left + ((right - left) &gt;&gt; 1); TreeNode root = new TreeNode(nums[mid]); root.left = traversal(nums, left, mid - 1); root.right = traversal(nums, mid + 1, right); return root; }} Iteration 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { public TreeNode sortedArrayToBST(int[] nums) { if (nums.length == 0) return null; //initial root node TreeNode root = new TreeNode(-1); Queue&lt;TreeNode&gt; nodeQueue = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; leftQueue = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; rightQueue = new LinkedList&lt;&gt;(); // put root node in queue nodeQueue.offer(root); leftQueue.offer(0); rightQueue.offer(nums.length - 1); while (!nodeQueue.isEmpty()) { TreeNode currNode = nodeQueue.poll(); int left = leftQueue.poll(); int right = rightQueue.poll(); int mid = left + ((right - left) &gt;&gt; 1); currNode.val = nums[mid]; if (left &lt;= mid - 1) { currNode.left = new TreeNode(-1); nodeQueue.offer(currNode.left); leftQueue.offer(left); rightQueue.offer(mid - 1); } if (right &gt;= mid + 1) { currNode.right = new TreeNode(-1); nodeQueue.offer(currNode.right); leftQueue.offer(mid + 1); rightQueue.offer(right); } } return root; }} &amp;PythonRecursion 1234567891011121314151617181920class Solution: def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode: root = self.traversal(nums, 0, len(nums)-1) return root def traversal(self, nums: List[int], left: int, right: int) -&gt; TreeNode: # Base Case if left &gt; right: return None mid = left + (right - left) // 2 mid_root = TreeNode(nums[mid]) mid_root.left = self.traversal(nums, left, mid-1) mid_root.right = self.traversal(nums, mid+1, right) return mid_root","link":"/2022/07/31/ConvertSortedArraytoBinarySearchTree/"},{"title":"Design Linked List","text":"Implement the MyLinkedList class: int get(int index) Get the value of the indexth node in the linked list. If the index is invalid, return -1. void addAtHead(int val) Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. void addAtTail(int val) Append a node of value val as the last element of the linked list. void addAtIndex(int index, int val) Add a node of value val before the indexth node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted. void deleteAtIndex(int index) Delete the indexth node in the linked list, if the index is valid. Example: Input [&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;] [[], [1], [3], [1, 2], [1], [1], [1]] Output [null, null, null, null, 2, null, 3] Explanation MyLinkedList myLinkedList = new MyLinkedList(); myLinkedList.addAtHead(1); myLinkedList.addAtTail(3); myLinkedList.addAtIndex(1, 2); // linked list becomes 1-&gt;2-&gt;3 myLinkedList.get(1); // return 2 myLinkedList.deleteAtIndex(1); // now the linked list is 1-&gt;3 myLinkedList.get(1); // return 3 Two ways of manipulating a linked list: 1. Use the original linked list 2. Setting a dummy head node The following is used to set a dummy head node (this is more convenient, as you can see by looking at the code) &amp;C++class MyLinkedList { public: // Define the linked list node structure struct LinkedNode { int val; LinkedNode* next; LinkedNode(int val):val(val), next(nullptr){} }; // Initialise a linked list MyLinkedList() { _dummyHead = new LinkedNode(0); // a dummy node _size = 0; } // Get the value of the index node, return -1 if index is illegal, note that index starts at 0 and the 0th node is the head node int get(int index) { if (index &gt; (_size - 1) || index &lt; 0) { return -1; } LinkedNode* cur = _dummyHead-&gt;next; while(index--){ // if--index we will fall into loop cur = cur-&gt;next; } return cur-&gt;val; } // Insert a node at the top of the linked list, and when the insertion is complete, the newly inserted node is the new head node of the linked list void addAtHead(int val) { LinkedNode* newNode = new LinkedNode(val); newNode-&gt;next = _dummyHead-&gt;next; _dummyHead-&gt;next = newNode; _size++; } // Add a node to the end of the list void addAtTail(int val) { LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(cur-&gt;next != nullptr){ cur = cur-&gt;next; } cur-&gt;next = newNode; _size++; } // A new node is inserted before the index node, e.g. if index is 0, then the new inserted node is the new head node of the chain. // If index is equal to the length of the list, then the newly inserted node is the end node of the list. // if index is greater than the length of the list, then return null // If index is less than 0, set to 0 as the new head node of the linked list. void addAtIndex(int index, int val) { if (index &gt; _size || index &lt; 0) { return; } LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(index--) { cur = cur-&gt;next; } newNode-&gt;next = cur-&gt;next; cur-&gt;next = newNode; _size++; } // Delete the index node, if the index is larrger than or equal to the length of the linked list, return directly, note that the index starts from 0 void deleteAtIndex(int index) { if (index &gt;= _size || index &lt; 0) { return; } LinkedNode* cur = _dummyHead; while(index--) { cur = cur -&gt;next; } LinkedNode* tmp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; delete tmp; _size--; } // print linked list void printLinkedList() { LinkedNode* cur = _dummyHead; while (cur-&gt;next != nullptr) { cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; &quot; &quot;; cur = cur-&gt;next; } cout &lt;&lt; endl; } private: int _size; LinkedNode* _dummyHead; }; &amp;Ctypedef struct { int val; struct MyLinkedList* next; }MyLinkedList; /** Initialize your data structure here. */ MyLinkedList* myLinkedListCreate() { //a dummy node MyLinkedList* head = (MyLinkedList *)malloc(sizeof (MyLinkedList)); head-&gt;next = NULL; return head; } /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */ int myLinkedListGet(MyLinkedList* obj, int index) { MyLinkedList *cur = obj-&gt;next; for (int i = 0; cur != NULL; i++){ if (i == index){ return cur-&gt;val; } else{ cur = cur-&gt;next; } } return -1; } /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */ void myLinkedListAddAtHead(MyLinkedList* obj, int val) { MyLinkedList *nhead = (MyLinkedList *)malloc(sizeof (MyLinkedList)); nhead-&gt;val = val; nhead-&gt;next = obj-&gt;next; obj-&gt;next = nhead; } /** Append a node of value val to the last element of the linked list. */ void myLinkedListAddAtTail(MyLinkedList* obj, int val) { MyLinkedList *cur = obj; while(cur-&gt;next != NULL){ cur = cur-&gt;next; } MyLinkedList *ntail = (MyLinkedList *)malloc(sizeof (MyLinkedList)); ntail-&gt;val = val; ntail-&gt;next = NULL; cur-&gt;next = ntail; } /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */ void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) { if (index == 0){ myLinkedListAddAtHead(obj, val); return; } MyLinkedList *cur = obj-&gt;next; for (int i = 1 ;cur != NULL; i++){ if (i == index){ MyLinkedList* newnode = (MyLinkedList *)malloc(sizeof (MyLinkedList)); newnode-&gt;val = val; newnode-&gt;next = cur-&gt;next; cur-&gt;next = newnode; return; } else{ cur = cur-&gt;next; } } } /** Delete the index-th node in the linked list, if the index is valid. */ void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) { if (index == 0){ MyLinkedList *tmp = obj-&gt;next; if (tmp != NULL){ obj-&gt;next = tmp-&gt;next; free(tmp) } return; } MyLinkedList *cur = obj-&gt;next; for (int i = 1 ;cur != NULL &amp;&amp; cur-&gt;next != NULL; i++){ if (i == index){ MyLinkedList *tmp = cur-&gt;next; if (tmp != NULL) { cur-&gt;next = tmp-&gt;next; free(tmp); } return; } else{ cur = cur-&gt;next; } } } void myLinkedListFree(MyLinkedList* obj) { while(obj != NULL){ MyLinkedList *tmp = obj; obj = obj-&gt;next; free(tmp); } } /** * Your MyLinkedList struct will be instantiated and called as such: * MyLinkedList* obj = myLinkedListCreate(); * int param_1 = myLinkedListGet(obj, index); * myLinkedListAddAtHead(obj, val); * myLinkedListAddAtTail(obj, val); * myLinkedListAddAtIndex(obj, index, val); * myLinkedListDeleteAtIndex(obj, index); * myLinkedListFree(obj); */ &amp;Java//single linked list class ListNode { int val; ListNode next; ListNode(){} ListNode(int val) { this.val=val; } } class MyLinkedList { //size of this linked list int size; //dummy node ListNode head; //initialise linked list public MyLinkedList() { size = 0; head = new ListNode(0); } //get the value of index node public int get(int index) { //if index is illgel return -1 if (index &lt; 0 || index &gt;= size) { return -1; } ListNode currentNode = head; // the list contains a dummy node, so we find the node of index+1 for (int i = 0; i &lt;= index; i++) { currentNode = currentNode.next; } return currentNode.val; } //Insert a node at the top of the list public void addAtHead(int val) { addAtIndex(0, val); } //Insert a node at the end of the list public void addAtTail(int val) { addAtIndex(size, val); } // Insert a new node before the index node, e.g. if index is 0, then the newly inserted node is the new head node of the list. // If index is equal to the length of the list, then the newly inserted node is the end node of the list // If index is larger than the length of the list, then return null public void addAtIndex(int index, int val) { if (index &gt; size) { return; } if (index &lt; 0) { index = 0; } size++; //find the fronter of the inserted node ListNode pred = head; for (int i = 0; i &lt; index; i++) { pred = pred.next; } ListNode toAdd = new ListNode(val); toAdd.next = pred.next; pred.next = toAdd; } //detele the node of index public void deleteAtIndex(int index) { if (index &lt; 0 || index &gt;= size) { return; } size--; if (index == 0) { head = head.next; return; } ListNode pred = head; for (int i = 0; i &lt; index ; i++) { pred = pred.next; } pred.next = pred.next.next; } } /** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList obj = new MyLinkedList(); * int param_1 = obj.get(index); * obj.addAtHead(val); * obj.addAtTail(val); * obj.addAtIndex(index,val); * obj.deleteAtIndex(index); */","link":"/2021/12/09/DesignLinkedList/"},{"title":"Insert into a Binary Search Tree","text":"TEST YOURSELFYou are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. Example 1: 123Input: root = [4,2,7,1,3], val = 5Output: [4,2,7,1,3,5] Explanation: Another accepted tree is: HINTWe just need to follow the rules of the binary search tree to traverse and insert nodes when we encounter empty nodes. For example, insert element 10, we need to find the last node to insert it, the same reasoning to insert element 15, insert element 0, insert element 6. The next step is the process of traversing the binary search tree: Recursion Determine the parameters and return value of the recursive function: The parameters are the root node pointer, and the element to be inserted.We can use the return value to complete the assignment of the newly added node to its parent nodeThe return type of the recursive function is the node type TreeNode* 1TreeNode* insertIntoBST(TreeNode* root, int val) Determine the termination condition:The termination condition is to find the position of the node to be inserted when the traversed node is null, and to return the inserted node 1234if (root == NULL) { TreeNode* node = new TreeNode(val); return node;} The logic for determining the single-level recursion: We do not need to traverse the whole search tree.Because the search tree is directed, the direction of recursion can be determined by the value of the inserted elements. 1234 if (root == NULL) { TreeNode* node = new TreeNode(val); return node;} &amp;C++ 123456789101112class Solution {public: TreeNode* insertIntoBST(TreeNode* root, int val) { if (root == NULL) { TreeNode* node = new TreeNode(val); return node; } if (root-&gt;val &gt; val) root-&gt;left = insertIntoBST(root-&gt;left, val); if (root-&gt;val &lt; val) root-&gt;right = insertIntoBST(root-&gt;right, val); return root; }}; Iteration&amp;C++ 1234567891011121314151617181920class Solution {public: TreeNode* insertIntoBST(TreeNode* root, int val) { if (root == NULL) { TreeNode* node = new TreeNode(val); return node; } TreeNode* cur = root; TreeNode* parent = root; // we need to record last node, otherise we cannot give value to new node while (cur != NULL) { parent = cur; if (cur-&gt;val &gt; val) cur = cur-&gt;left; else cur = cur-&gt;right; } TreeNode* node = new TreeNode(val); if (val &lt; parent-&gt;val) parent-&gt;left = node;// Use parent node to give value else parent-&gt;right = node; return root; }}; &amp;JavaRecursion 12345678910111213141516171819202122class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) return new TreeNode(val); TreeNode newRoot = root; TreeNode pre = root; while (root != null) { pre = root; if (root.val &gt; val) { root = root.left; } else if (root.val &lt; val) { root = root.right; } } if (pre.val &gt; val) { pre.left = new TreeNode(val); } else { pre.right = new TreeNode(val); } return newRoot; }} Iteration 1234567891011121314class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) // if this node is empty, which means val finds the suitable position, return new node return new TreeNode(val); if (root.val &lt; val){ root.right = insertIntoBST(root.right, val); // create right subtree }else if (root.val &gt; val){ root.left = insertIntoBST(root.left, val); // create left subtree } return root; }} &amp;PythonRecursion 12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def insertIntoBST(self, root: TreeNode, val: int) -&gt; TreeNode: # Base Case if not root: return TreeNode(val) if val &lt; root.val: root.left = self.insertIntoBST(root.left, val) if root.val &lt; val: root.right = self.insertIntoBST(root.right, val) return root Iteration 123456789101112131415161718192021222324class Solution: def insertIntoBST(self, root: TreeNode, val: int) -&gt; TreeNode: if not root: return TreeNode(val) parent = None cur = root #use while loop to find the parent of new node while cur: if cur.val &lt; val: parent = cur cur = cur.right elif cur.val &gt; val: parent = cur cur = cur.left # the parent of new node has been found if parent.val &gt; val: parent.left = TreeNode(val) else: parent.right = TreeNode(val) return root","link":"/2022/07/15/InsertintoaBinarySearchTree/"},{"title":"Letter Combinations of a Phone Number","text":"TEST YOURSELFGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example 1: 12Input: digits = &quot;23&quot;Output: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;] HINTIn terms of examples, if we type “23”, the most straightforward idea would be a two-level for loop traversal, which would output all the combinations. But if we enter “233”, then it’s a three-level for loop, and if “2333”, then it’s a four-level for loop ……. There are three problems to solve: How to map numbers and letters n letters n for loops Input 1 * # keystrokes and so on exceptions 1. How to map numbers and lettersWe can use a map or define a two-dimensional array, e.g. string letterMap[10], to do the mapping. 123456789101112const string letterMap[10] = { &quot;&quot;, // 0 &quot;&quot;, // 1 &quot;abc&quot;, // 2 &quot;def&quot;, // 3 &quot;ghi&quot;, // 4 &quot;jkl&quot;, // 5 &quot;mno&quot;, // 6 &quot;pqrs&quot;, // 7 &quot;tuv&quot;, // 8 &quot;wxyz&quot;, // 9}; 2. Solve n-for loop by BackTrackingFor example, enter: “23” and abstract to a tree structure as shown in the figure. The graph shows the depth of the traversal, which is the length of the input “23”, and the leaf nodes are the results we want to collect, outputting [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. Backtracking function template return values and parameters string s to collect the results of the leaf nodes and then save them in a string array result The index is a record of the number of digits traversed, which is used to traverse digits and the index also indicates the depth of the tree. 123vector&lt;string&gt; result;string s;void backtracking(const string&amp; digits, int index) Termination conditions for backtracking functions For example, if the input case is “23”, two digits, then the root node is recursive down two levels and the leaf nodes are the result set to be collected. The termination condition is if index is equal to the number of digits (digits.size) entered (index was originally used to traverse the digits). The result is then collected, ending the recursion at this level. 1234 if (index == digits.size()) { result.push_back(s); return;} Traversal process for backtracking search we take the number pointed to by index and find the corresponding character set (the character set of the phone keyboard) 1234567 int digit = digits[index] - '0'; //change the number pointed by index to intstring letters = letterMap[digit]; // take the correponding character setfor (int i = 0; i &lt; letters.size(); i++) { s.push_back(letters[i]); // process node backtracking(digits, index + 1); // recursion，index+1 s.pop_back(); // backtracking} &amp;C++ 123456789101112131415161718192021222324252627282930313233343536373839 class Solution {private: const string letterMap[10] = { &quot;&quot;, // 0 &quot;&quot;, // 1 &quot;abc&quot;, // 2 &quot;def&quot;, // 3 &quot;ghi&quot;, // 4 &quot;jkl&quot;, // 5 &quot;mno&quot;, // 6 &quot;pqrs&quot;, // 7 &quot;tuv&quot;, // 8 &quot;wxyz&quot;, // 9 };public: vector&lt;string&gt; result; string s; void backtracking(const string&amp; digits, int index) { if (index == digits.size()) { result.push_back(s); return; } int digit = digits[index] - '0'; //change the number pointed by index to intstring letters = letterMap[digit]; // take the correponding character setfor (int i = 0; i &lt; letters.size(); i++) { s.push_back(letters[i]); // process node backtracking(digits, index + 1); // recursion，index+1 s.pop_back(); // backtracking}vector&lt;string&gt; letterCombinations(string digits) { s.clear(); result.clear(); if (digits.size() == 0) { return result; } backtracking(digits, 0); return result; }}; &amp;Java 12345678910111213141516171819202122232425262728293031323334353637 class Solution { // set global list to save final result List&lt;String&gt; list = new ArrayList&lt;&gt;(); public List&lt;String&gt; letterCombinations(String digits) { if (digits == null || digits.length() == 0) { return list; } String[] numString = {&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;}; //Interation backTracking(digits, numString, 0); return list; } StringBuilder temp = new StringBuilder(); public void backTracking(String digits, String[] numString, int num) { if (num == digits.length()) { list.add(temp.toString()); return; } String str = numString[digits.charAt(num) - '0']; for (int i = 0; i &lt; str.length(); i++) { temp.append(str.charAt(i)); //c backTracking(digits, numString, num + 1); temp.deleteCharAt(temp.length() - 1); } }} &amp;Python 123456789101112131415161718192021222324252627282930313233class Solution: def __init__(self): self.answers: List[str] = [] self.answer: str = '' self.letter_map = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } def letterCombinations(self, digits: str) -&gt; List[str]: self.answers.clear() if not digits: return [] self.backtracking(digits, 0) return self.answers def backtracking(self, digits: str, index: int) -&gt; None: # the backtacking funtion has no return value # Base Case if index == len(digits): self.answers.append(self.answer) return letters: str = self.letter_map[digits[index]] for letter in letters: self.answer += letter self.backtracking(digits, index + 1) self.answer = self.answer[:-1] # backtracking","link":"/2022/09/30/LetterCombinationsofaPhoneNumber/"},{"title":"Combinations-Pruning","text":"Pruning optimization There is the following code in the traversal process: 12345for (int i = startIndex; i &lt;= n; i++) { path.push_back(i); backtracking(n, k, i + 1); path.pop_back();} The range of this traversal can be pruned and optimised, how? For example, if n = 4 and k = 4, then at the first level of the for loop, all traversals from element 2 are meaningless. At the second level of the for loop, the traversal from element 3 onwards is meaningless. This is a little abstract, as shown in the diagram: Each node in the diagram (rectangle in the diagram) represents a for-loop at this level, so each level of for-loops starting from the second number is meaningless and is an invalid traversal. Thus, the place to prune is at the starting position chosen by the for loop at each level of the recursion. If the number of elements after the start of the for loop is already less than the number of elements we need, then there is no need to search. Note that i in the code is the starting position selected in the for loop. Next, look at the optimization process as follows: Number of elements already selected: path.size(); The number of elements still needed is: k - path.size(); The set n must be traversed from at most the starting position : n - (k - path.size()) + 1, starting traversal The reason for the +1 is: we want a left-closed setincluding the starting position. For example, n = 4, k = 3, the element already selected is 0 (path.size is 0), n - (k - 0) + 1 i.e. 4 - ( 3 - 0) + 1 = 2.It is reasonable to search all from 2, which can be the combination [2, 3, 4]. So the optimized for loop is: 12345678910111213141516171819202122class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(int n, int k, int startIndex) { if (path.size() == k) { result.push_back(path); return; } for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) { // optimized for loop path.push_back(i); // process node backtracking(n, k, i + 1); path.pop_back(); // backtracking } }public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { backtracking(n, k, 1); return result; }}; &amp;Java 1234567891011121314151617181920class Solution { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { combineHelper(n, k, 1); return result; } private void combineHelper(int n, int k, int startIndex){ //termination if (path.size() == k){ result.add(new ArrayList&lt;&gt;(path)); return; } for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++){ path.add(i); combineHelper(n, k, i + 1); path.removeLast(); } }} &amp;Python 1234567891011121314class Solution: def combine(self, n: int, k: int) -&gt; List[List[int]]: res=[] path=[] def backtrack(n,k,startIndex): if len(path) == k: res.append(path[:]) return for i in range(startIndex,n-(k-len(path))+2): #optimized for loop path.append(i) #process node backtrack(n,k,i+1) # recursion path.pop() #backtrack backtrack(n,k,1) return res","link":"/2022/09/15/Combinations-Pruning/"},{"title":"Level Order Traversal of Binary Tree","text":"Given the root of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level). Example1: 123Input: root = [3,9,20,null,null,15,7]Output: [[3],[9,20],[15,7]] Example2: 12Input: root = [1]Output: [[1]] HINTLevel order Traversal: This means traversing the binary tree one layer at a time from left to right.This is achieved by borrowing an auxiliary data structure: the queue, which is FIFO(first-in-first-out), in line with the logic of layer-by-layer traversal. This level order traversal is the breadth-first traversal in graph theory, except that we apply it to binary trees. A breadth-first traversal of a binary tree using a queue is as follows. &amp;C++123456789101112131415161718192021class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { queue&lt;TreeNode*&gt; que; if (root != NULL) que.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (!que.empty()) { int size = que.size(); vector&lt;int&gt; vec; // fixed siize(since que.size is changing) for (int i = 0; i &lt; size; i++) { TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); } result.push_back(vec); } return result; }}; Iteration 1234567891011121314151617class Solution {public: void order(TreeNode* cur, vector&lt;vector&lt;int&gt;&gt;&amp; result, int depth) { if (cur == nullptr) return; if (result.size() == depth) result.push_back(vector&lt;int&gt;()); result[depth].push_back(cur-&gt;val); order(cur-&gt;left, result, depth + 1); order(cur-&gt;right, result, depth + 1); } vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; result; int depth = 0; order(root, result, depth); return result; }}; &amp;Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution { public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { //checkFun01(root,0); checkFun02(root); return resList; } //DFS--Resursion public void checkFun01(TreeNode node, Integer deep) { if (node == null) return; deep++; if (resList.size() &lt; deep) { //when number of level is larger,the item of list is larger. we use the index of list to distinguish diffrent levels List&lt;Integer&gt; item = new ArrayList&lt;Integer&gt;(); resList.add(item); } resList.get(deep - 1).add(node.val); checkFun01(node.left, deep); checkFun01(node.right, deep); } //BFS--Iteration--use queue public void checkFun02(TreeNode node) { if (node == null) return; Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;(); que.offer(node); while (!que.isEmpty()) { List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;(); int len = que.size(); while (len &gt; 0) { TreeNode tmpNode = que.poll(); itemList.add(tmpNode.val); if (tmpNode.left != null) que.offer(tmpNode.left); if (tmpNode.right != null) que.offer(tmpNode.right); len--; } resList.add(itemList); } } }","link":"/2022/04/30/LevelOrderTraversalofBinaryTree/"},{"title":"Minimum Size Subarray Sum","text":"Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, …, numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead. Input: target = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: The subarray [4,3] has the minimal length under the problem constraint. First Solutoinwe can directly use two for loop but it has bad Runtime O(n^2) class Solution { public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) { int result = INT32_MAX; // final result int sum = 0; // the sum of subaray int subLength = 0; // the length of subaray for (int i = 0; i &lt; nums.size(); i++) { // set the start of subarray is i sum = 0; for (int j = i; j &lt; nums.size(); j++) { // set the start of subarray is j sum += nums[j]; if (sum &gt;= s) { // update result when sum of subarray is bigger than s subLength = j - i + 1; // update the length of subarray result = result &lt; subLength ? result : subLength; break; // once we find the result, break } } } // no relative result return result == INT32_MAX ? 0 : result; } }; Time Complexity : O(n^2) Space Complexity : O(1) Better Solutionwe can choose double pointer to solve this question.Imagine a double pointer as a sliding window: The window is the smallest continuous subarray of its length that satisfies the sum ≥ s. How the start of the window is moved?: if the current window is larger than s, the window is moved forward (i.e. it is time to shrink). How to move the end of the window: The end of the window is the pointer to the traversal array, which is the index in the for loop. C++ class Solution { public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) { int result = INT32_MAX; //set initial result as an infitine maxinum int sum = 0; // the sum of sliding window int i = 0; // the start of sliding window int subLength = 0; // the length of sliding window for (int j = 0; j &lt; nums.size(); j++) { sum += nums[j]; while (sum &gt;= s) { subLength = (j - i + 1); // update the length of sliding window result = result &lt; subLength ? result : subLength; sum -= nums[i++]; // update i, which means shrink sliding window } } // return result == INT32_MAX ? 0 : result; } }; Time Complexity : O(n) Space Complexity : O(1) Java class Solution { public int minSubArrayLen(int s, int[] nums) { int left = 0; int sum = 0; int result = Integer.MAX_VALUE; for (int right = 0; right &lt; nums.length; right++) { sum += nums[right]; while (sum &gt;= s) { result = Math.min(result, right - left + 1); sum -= nums[left++]; } } return result == Integer.MAX_VALUE ? 0 : result; } }","link":"/2021/10/21/Minimum%20Size%20Subarray%20Sum/"},{"title":"Maximum Depth of Binary Tree","text":"TEST YOURSELFGiven the root of a binary tree, return its maximum depth. A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Example1: Input: root = [3,9,20,null,null,15,7] Output: 3 HINTResursionThe problem can be solved using either preorder (parent left and right) or postorder traversal (left and right parent), using preorder to find the depth and postorder to find the height. The depth of a binary tree node: the number of edges or nodes of the longest simple path from the root node to that node (depending on whether the depth starts at 0 or 1) The height of a binary tree node: the number of edges of the longest simple path from that node to the leaf node (depending on whether the height starts at 0 or 1) The height of the root node is the maximum depth of the binary tree, so in this problem we find the maximum depth of the binary tree by the height of the root node in the post-order. we start with a post-order traversal (left and right middle) to calculate the height of the tree. Determine the parameters and return value of the recursive function: the parameter is the root node of the incoming tree, and the return returns the depth of the tree, so the return value is of type int.The code is as follows. int getdepth(treenode* node) Determine the termination condition: if the node is empty, 0 is returned, indicating a height of 0. if (node == NULL) return 0; The logic for determining the single-level recursion: first find the depth of its left subtree, then the depth of its right subtree, and finally take the largest value of the left and right depths and add 1 (plus 1 because the current middle node is included) to the depth of the tree whose current node is the root node. int leftdepth = getdepth(node-&gt;left); // left int rightdepth = getdepth(node-&gt;right); // right int depth = 1 + max(leftdepth, rightdepth); // parent return depth; &amp;C++ class solution { public: int getdepth(treenode* node) { if (node == NULL) return 0; int leftdepth = getdepth(node-&gt;left); // left int rightdepth = getdepth(node-&gt;right); // right int depth = 1 + max(leftdepth, rightdepth); // parent return depth; } int maxdepth(treenode* root) { return getdepth(root); } }; IterationUsing the iterative method, it is most appropriate to use a level order traversal, because the **maximum depth **is the number of layers in the binary tree, which fits perfectly with the level order traversal. As shown in the figure: &amp;C++class solution { public: int maxdepth(treenode* root) { if (root == NULL) return 0; int depth = 0; queue&lt;treenode*&gt; que; que.push(root); while(!que.empty()) { int size = que.size(); depth++; // record depth for (int i = 0; i &lt; size; i++) { treenode* node = que.front(); que.pop(); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); } } return depth; } }; &amp;Java class solution { /** * Resursion */ public int maxDepth(TreeNode root) { if (root == null) { return 0; } int leftDepth = maxDepth(root.left); int rightDepth = maxDepth(root.right); return Math.max(leftDepth, rightDepth) + 1; } } class solution { /** * Iteration by level order traversal */ public int maxDepth(TreeNode root) { if(root == null) { return 0; } Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(root); int depth = 0; while (!deque.isEmpty()) { int size = deque.size(); depth++; for (int i = 0; i &lt; size; i++) { TreeNode node = deque.poll(); if (node.left != null) { deque.offer(node.left); } if (node.right != null) { deque.offer(node.right); } } } return depth; } } &amp;PythonResursion class solution: def maxdepth(self, root: treenode) -&gt; int: if not root: return 0 return 1 + max(self.maxdepth(root.left), self.maxdepth(root.right)) Iteration import collections class solution: def maxdepth(self, root: treenode) -&gt; int: if not root: return 0 depth = 0 #record depth queue = collections.deque() queue.append(root) while queue: size = len(queue) depth += 1 for i in range(size): node = queue.popleft() if node.left: queue.append(node.left) if node.right: queue.append(node.right) return depth","link":"/2022/05/31/MaximumDepthofBinaryTree/"},{"title":"Merge Two Binary Trees","text":"TEST YOURSELFYou are given two binary trees root1 and root2. Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree. Return the merged tree. Note: The merging process must start from the root nodes of both trees. Example 1: Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7] Output: [3,4,5,5,4,null,7] HINTIt’s actually the same logic as traversing a tree, except that the nodes of both trees are passed in and operated on simultaneously. ResursionUse pre-order as an example: Determine the parameters and return value of the recursive function: To merge two binary trees, then the argument is passed at least the root node of both binary trees, and the return value is the root node of the merged binary tree. TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) { Determine the termination condition: Since two trees are passed in, there will be two trees traversing nodes t1 and t2. If t1 == NULL, the two trees will be merged into t2 (it doesn’t matter if t2 is also NULL, it will be NULL after the merge). If t2 == NULL, then the two numbers are merged into t1 (it doesn’t matter if t1 is also NULL, the merge is NULL). if (t1 == NULL) return t2; if (t2 == NULL) return t1; The logic for determining the single-level recursion: Adding the elements of two trees together t1-&gt;val += t2-&gt;val; The left subtree of t1 is: the left subtree after merging the left subtree of t1 and the left subtree of t2. The right subtree of t1 is: the right subtree after merging the right subtree of t1 and the right subtree of t2. The final t1 is the root node after the merge. t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left); t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right); return t1; &amp;C++ Complete code class Solution { public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) { if (t1 == NULL) return t2; if (t2 == NULL) return t1; // re-define new node, don't modity structure of the 2 old tree TreeNode* root = new TreeNode(0); root-&gt;val = t1-&gt;val + t2-&gt;val; root-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left); root-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right); return root; } }; Iteration&amp;C++ class Solution { public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) { if (t1 == NULL) return t2; if (t2 == NULL) return t1; queue&lt;TreeNode*&gt; que; que.push(t1); que.push(t2); while(!que.empty()) { TreeNode* node1 = que.front(); que.pop(); TreeNode* node2 = que.front(); que.pop(); // add val node1-&gt;val += node2-&gt;val; // if thel left node of 2 trees are both not empty, enter queue if (node1-&gt;left != NULL &amp;&amp; node2-&gt;left != NULL) { que.push(node1-&gt;left); que.push(node2-&gt;left); } // if thel right node of 2 trees are both noe empty, enter queue if (node1-&gt;right != NULL &amp;&amp; node2-&gt;right != NULL) { que.push(node1-&gt;right); que.push(node2-&gt;right); } // when left node of t1=null, t2 !=null, set val if (node1-&gt;left == NULL &amp;&amp; node2-&gt;left != NULL) { node1-&gt;left = node2-&gt;left; } // when right node of t1=null, t2 !=null, set val if (node1-&gt;right == NULL &amp;&amp; node2-&gt;right != NULL) { node1-&gt;right = node2-&gt;right; } } return t1; } }; &amp;Java Recursion class Solution { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null) return root2; if (root2 == null) return root1; root1.val += root2.val; root1.left = mergeTrees(root1.left,root2.left); root1.right = mergeTrees(root1.right,root2.right); return root1; } } Iteration class Solution { // using queue public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null) return root2; if (root2 ==null) return root1; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root1); queue.offer(root2); while (!queue.isEmpty()) { TreeNode node1 = queue.poll(); TreeNode node2 = queue.poll(); node1.val = node1.val + node2.val; if (node1.left != null &amp;&amp; node2.left != null) { queue.offer(node1.left); queue.offer(node2.left); } if (node1.right != null &amp;&amp; node2.right != null) { queue.offer(node1.right); queue.offer(node2.right); } if (node1.left == null &amp;&amp; node2.left != null) { node1.left = node2.left; } if (node1.right == null &amp;&amp; node2.right != null) { node1.right = node2.right; } } return root1; } } &amp;Python Recursion # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def mergeTrees(self, root1: TreeNode, root2: TreeNode) -&gt; TreeNode: if not root1: return root2 if not root2: return root1 root1.val += root2.val # 中 root1.left = self.mergeTrees(root1.left, root2.left) #left root1.right = self.mergeTrees(root1.right, root2.right) # right return root1 Iteration class Solution: def mergeTrees(self, root1: TreeNode, root2: TreeNode) -&gt; TreeNode: if not root1: return root2 if not root2: return root1 queue = deque() queue.append(root1) queue.append(root2) while queue: node1 = queue.popleft() node2 = queue.popleft() # update queue if node1.left and node2.left: queue.append(node1.left) queue.append(node2.left) if node1.right and node2.right: queue.append(node1.right) queue.append(node2.right) node1.val += node2.val if not node1.left and node2.left: node1.left = node2.left if not node1.right and node2.right: node1.right = node2.right return root1","link":"/2022/06/30/MergeTwoBinaryTrees/"},{"title":"Remove Linked List Elements","text":"Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head. Example1: Input: head = [1,2,6,3,4,5,6], val = 6 Output: [1,2,3,4,5] Example2: Input: head = [7,7,7,7], val = 7 Output: [] HINT If we use C, after deleting the target node, we also need to delete the original memory of the deleted node If we use Java or Python we don’t need to manage memory manually The following two ways of manipulating a linked list are involved here. Using the original linked list Set a dummy head node 1. Using the original linked listRemoving the head node is not the same as removing other nodes, as the other nodes in the chain are removed from the current node by the previous node, whereas the head node does not have a previous node. So how do you remove the head node? In fact, all you have to do is move the head node back one position, which removes a head node from the chain. Don’t forget to delete the original head node from memory. 2. Set a dummy head nodeRemoving the head node in a single linked list is not the same as removing other nodes, so could there be a uniform logic for removing nodes in a linked list? It is actually possible to set up a dummy head node so that all nodes of the original chain list can be removed in a uniform manner.To show how to set up a dummy head node. we are still in this linked list, remove element 1.Here’s how to add a dummy head node as a new head node to the linked list, removing this old head node element 1 at this point. &amp;C #Type1: Use Original Linked list class Solution { public: ListNode* removeElements(ListNode* head, int val) { // delete head node while (head != NULL &amp;&amp; head-&gt;val == val) { // NOtice:not if here ListNode* tmp = head; head = head-&gt;next; delete tmp; } // delete non-head node ListNode* cur = head; while (cur != NULL &amp;&amp; cur-&gt;next!= NULL) { if (cur-&gt;next-&gt;val == val) { ListNode* tmp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; delete tmp; } else { cur = cur-&gt;next; } } return head; } }; #Type2: Set a dummy head node class Solution { public: ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0); // Set a dummy head node dummyHead-&gt;next = head; // let the dummy head node point to head so that we can delete target later ListNode* cur = dummyHead; while (cur-&gt;next != NULL) { if(cur-&gt;next-&gt;val == val) { ListNode* tmp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; delete tmp; } else { cur = cur-&gt;next; } } head = dummyHead-&gt;next; delete dummyHead; return head; } }; &amp;Java #Type1: set dummy node public ListNode removeElements(ListNode head, int val) { if (head == null) { return head; } // since the delete operation refers to head node, so we set a dummy node ListNode dummy = new ListNode(-1, head); ListNode pre = dummy; ListNode cur = head; while (cur != null) { if (cur.val == val) { pre.next = cur.next; } else { pre = cur; } cur = cur.next; } return dummy.next; } #Type2: set a pre node public ListNode removeElements(ListNode head, int val) { while (head != null &amp;&amp; head.val == val) { head = head.next; } if (head == null) { return head; } ListNode pre = head; ListNode cur = head.next; while (cur != null) { if (cur.val == val) { pre.next = cur.next; } else { pre = cur; } cur = cur.next; } return head; } #Type3: Do not set a dummy node or pre node public ListNode removeElements(ListNode head, int val) { while(head!=null &amp;&amp; head.val==val){ head = head.next; } ListNode curr = head; while(curr!=null){ while(curr.next!=null &amp;&amp; curr.next.val == val){ curr.next = curr.next.next; } curr = curr.next; } return head; } Time Complexity: O(n)Space Complexty: O(1)","link":"/2021/11/28/RemoveLinkedListElements/"},{"title":"LinkedList Basic","text":"1.The type of LinkedlistWhat is a linked list? A linked list is a linear data structure linked together by pointers. Each node consists of two parts, a data field and a pointer field (which holds a pointer to the next node), with the last node having a pointer field pointing to null (meaning a null pointer) The start node of the link is called the head node of the chain. 1. Single Linked List A pointer field in a single-linked list can only point to its next node. 2. Double Linked List Each node has two pointer fields, one pointing to the next node and one pointing to the previous node. 3. Circular Linked List The circular linked list is a linked list where all nodes are connected to form a circle. In a circular linked list, the first node and the last node are connected to each other which forms a circle. There is no NULL at the end. ![Example of Circular Linked List)(Circular.jpg) 2.Memory of Linked listA linked list is linked to nodes in memory by pointers in the pointer field.Therefore, the nodes are not distributed continuously in memory, but are scattered at certain addresses in memory, and the allocation mechanism depends on the memory management of the operating system. shown as follow: 3. Definition of Linked listC/C++ // Single Linked List struct ListNode { int val; // value of this node ListNode *next; // the pointer ListNode(int x) : val(x), next(NULL) {} // struct function }; Java public class ListNode { // the value of node int val; // next nohde ListNode next; // the struct function of node(no parameter) public ListNode() { } // the struct function of node(one parameter) public ListNode(int val) { this.val = val; } //the struct function of node(two parameter) public ListNode(int val, ListNode next) { this.val = val; this.next = next; } } }; 3.The Operation of Linked List Detele Node![] if we want to delete node D, we should only change the pointer of C to Node E. Add Node","link":"/2021/11/07/LinkedList%20Basic/"},{"title":"Minimum Depth of Binary Tree","text":"TEST YOURSELFGiven a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example 1: Input: root = [3,9,20,null,null,15,7] Output: 2 Example 2: Input: root = [2,null,3,null,4,null,5,null,6] Output: 5 HINTIntuitively, it seems to be similar to finding the maximum depth, but in fact it is still quite different. In the following explanation, we still use post-ordertraversal in the order of traversal (because we want to compare the results after the recursive returns) We first need to understand the definition of minimum depth: the minimum depth is the number of nodes on the shortest path from the root node to the nearest leaf node Recursion Determine the parameters and return value of the recursive function: The parameter is the root node of the binary tree to be passed in, and the depth returned is of type int. int getDepth(TreeNode* node) Determine the termination condition: if the node is empty, 0 is returned, indicating a height of 0. if (node == NULL) return 0; The logic for determining the single-level recursion: If the left subtree is empty and the right subtree is not empty, then the minimum depth is: 1 + the depth of the right subtree. Conversely, if the right subtree is empty and the left subtree is not empty, the minimum depth is: 1 + the depth of the left subtree. Finally, if neither the left nor the right subtree is empty, return the minimum depth of the left or right subtree+1. // it is not the most deep node when the left subtree is empty and the right subtree is not empty if (node-&gt;left == NULL &amp;&amp; node-&gt;right != NULL) { return 1 + rightDepth; } // it is not the most deep node when the left subtree is not empty and the right subtree is empty if (node-&gt;left != NULL &amp;&amp; node-&gt;right == NULL) { return 1 + leftDepth; } int result = 1 + min(leftDepth, rightDepth); return result; &amp;C++ class Solution { public: int minDepth(TreeNode* root) { if (root == NULL) return 0; if (root-&gt;left == NULL &amp;&amp; root-&gt;right != NULL) { return 1 + minDepth(root-&gt;right); } if (root-&gt;left != NULL &amp;&amp; root-&gt;right == NULL) { return 1 + minDepth(root-&gt;left); } return 1 + min(minDepth(root-&gt;left), minDepth(root-&gt;right)); } }; Iteration &amp;C++ class Solution { public: int minDepth(TreeNode* root) { if (root == NULL) return 0; int depth = 0; queue&lt;TreeNode*&gt; que; que.push(root); while(!que.empty()) { int size = que.size(); depth++; // reord for (int i = 0; i &lt; size; i++) { TreeNode* node = que.front(); que.pop(); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); if (!node-&gt;left &amp;&amp; !node-&gt;right) { return depth; } } } return depth; } }; &amp;Java Resursion class Solution { public int minDepth(TreeNode root) { if (root == null) { return 0; } int leftDepth = minDepth(root.left); int rightDepth = minDepth(root.right); if (root.left == null) { return rightDepth + 1; } if (root.right == null) { return leftDepth + 1; } // both left node and right node are not empty return Math.min(leftDepth, rightDepth) + 1; } } Iteration class Solution { public int minDepth(TreeNode root) { if (root == null) { return 0; } Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(root); int depth = 0; while (!deque.isEmpty()) { int size = deque.size(); depth++; for (int i = 0; i &lt; size; i++) { TreeNode poll = deque.poll(); if (poll.left == null &amp;&amp; poll.right == null) { # // when iterate leaf node ,return directly. since it is level oreder traversal, this value is minimum return depth; } if (poll.left != null) { deque.offer(poll.left); } if (poll.right != null) { deque.offer(poll.right); } } } return depth; } } &amp;Python Resursion class Solution: def minDepth(self, root: TreeNode) -&gt; int: if not root: return 0 if not root.left and not root.right: return 1 min_depth = 10**9 if root.left: # min_depth = min(self.minDepth(root.left), min_depth) # the minimum depth of left subtree if root.right: min_depth = min(self.minDepth(root.right), min_depth) # the minimum depth of right subtree return min_depth + 1 Iteration class Solution: def minDepth(self, root: TreeNode) -&gt; int: if not root: return 0 if not root.left and not root.right: return 1 min_depth = 10**9 if root.left: min_depth = min(self.minDepth(root.left), min_depth) # the minimum depth of left subtree if root.right: min_depth = min(self.minDepth(root.right), min_depth) # the minimum depth of right subtree return min_depth + 1","link":"/2022/06/14/MinimumDepthofBinaryTree/"},{"title":"Repeated Substring Pattern(2)","text":"There is a problem with move matching: we end up with the process of determining whether a string (s + s) has an occurrence of s. We could just use libraries like contains, find and so on. This ignores the time complexity of implementing these functions (the brute force solution is m * n, and the general library implementation is O(m + n))","link":"/2022/03/11/RepeatedSubstringPattern(2)/"},{"title":"Replace spaces","text":"TEST YOURSELFPlease implement a function that replaces each space in the string s with “%20”. Example 1: Input: s = &quot;We are happy.&quot; Output: &quot;We%20are%20happy.&quot; HINTThe highlight of this puzzle is that no extra auxiliary space is used. Step1: Expand the array to the size after each space has been replaced with “%20”. Step2: Replace the spaces from back to front, i.e. the double pointer method, as follows: i points to the end of the new length and j points to the end of the old length. Why do we need to fill from back to front?Filling from front to back is an O(n^2) algorithm, because each time an element is added, all the elements after the added element are moved backwards In fact, for many array padding problems, we can pre-fill the array with the size of the padding, and then work backwards and forwards. Doing this has two advantages: Don’t need to request new arrays. By filling the elements backwards and forwards, we avoid having to move all the elements backwards after the added elements each time they are added. &amp;C++class Solution { public: string replaceSpace(string s) { int count = 0; // count the number of spaces int sOldSize = s.size(); for (int i = 0; i &lt; s.size(); i++) { if (s[i] == ' ') { count++; } } // expand the size of string s(after replacing 20%) s.resize(s.size() + count * 2); int sNewSize = s.size(); // replace spaces with 20% from back to front for (int i = sNewSize - 1, j = sOldSize - 1; j &lt; i; i--, j--) { if (s[j] != ' ') { s[i] = s[j]; } else { s[i] = '0'; s[i - 1] = '2'; s[i - 2] = '%'; i -= 2; } } return s; } }; Time Complexity：O(n) Space Complexity：O(1) &amp;Cchar* replaceSpace(char* s){ int count = 0; int len = strlen(s); for (int i = 0; i &lt; len; i++) { if (s[i] == ' ') { count++; } } int newLen = len + count * 2; char* result = malloc(sizeof(char) * newLen + 1); for (int i = len - 1, j = newLen - 1; i &gt;= 0; i--, j--) { if (s[i] != ' ') { result[j] = s[i]; } else { result[j--] = '0'; result[j--] = '2'; result[j] = '%'; } } result[newLen] = '\\0'; return result; } &amp;Javapublic String replaceSpace(String s) { if(s == null || s.length() == 0){ return s; } //expand size, double number of spaces StringBuilder str = new StringBuilder(); for (int i = 0; i &lt; s.length(); i++) { if(s.charAt(i) == ' '){ str.append(&quot; &quot;); } } // no space, return s if(str.length() == 0){ return s; } //double pointer int left = s.length() - 1;//left： point to end of the old string s += str.toString(); int right = s.length()-1;//right：point to end of the new string char[] chars = s.toCharArray(); while(left&gt;=0){ if(chars[left] == ' '){ chars[right--] = '0'; chars[right--] = '2'; chars[right] = '%'; }else{ chars[right] = chars[left]; } left--; right--; } return new String(chars); }","link":"/2022/02/11/Replacespaces/"},{"title":"Reverse Linked List","text":"Given the head of a singly linked list, reverse the list, and return the reversed list. Input: head = [1,2,3,4,5] Output: [5,4,3,2,1] HINTIt would actually be a waste of memory space to define a new chain table and implement the inversion of the elements of the chain table. In fact, you only need to change the pointing of the next pointer of the chain table to invert it directly without redefining a new chain table, as shown in the figure: Previously the head node of the chain was element 1, after reversing it the head node is element 5, no nodes are added or removed here, just the direction of the next pointer. Reverse flow: Firstly, define a cur pointer to the head node, and a pre pointer, initialized to null. Then it’s time to reverse the process, first by saving the cur-&gt;next node with the tmp pointer, that is, by saving this node. Why save this node? Because the next step is to change the cur-&gt;next pointer, so that cur-&gt;next points to pre, which has already reversed the first node. The next step is to loop through the following code logic, continuing to move the pre and cur pointers. Finally, the cur pointer is pointing to null, the loop is over and the chain is reversed. At this point we return the pre pointer and the pre pointer points to the new head node. &amp;C++1.Double Pointer class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* temp; // 保存cur的下一个节点 ListNode* cur = head; ListNode* pre = NULL; while(cur) { temp = cur-&gt;next; // 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next cur-&gt;next = pre; // 翻转操作 // 更新pre 和 cur指针 pre = cur; cur = temp; } return pre; } }; 2.Recursion public: ListNode* reverse(ListNode* pre,ListNode* cur){ if(cur == NULL) return pre; ListNode* temp = cur-&gt;next; cur-&gt;next = pre; // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步 // pre = cur; // cur = temp; return reverse(cur,temp); } ListNode* reverseList(ListNode* head) { // 和双指针法初始化是一样的逻辑 // ListNode* cur = head; // ListNode* pre = NULL; return reverse(NULL, head); } }; &amp;Java1.Double Pointer class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode cur = head; ListNode temp = null; while (cur != null) { temp = cur.next;// 保存下一个节点 cur.next = prev; prev = cur; cur = temp; } return prev; } } 2.Recursion class Solution { public ListNode reverseList(ListNode head) { return reverse(null, head); } private ListNode reverse(ListNode prev, ListNode cur) { if (cur == null) { return prev; } ListNode temp = null; temp = cur.next;// 先保存下一个节点 cur.next = prev;// 反转 // 更新prev、cur位置 // prev = cur; // cur = temp; return reverse(cur, temp); } } &amp;Python1.Double Pointer # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: cur = head pre = None while(cur!=None): temp = cur.next # 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next cur.next = pre #反转 #更新pre、cur指针 pre = cur cur = temp return pre 2.Recursion # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: def reverse(pre,cur): if not cur: return pre tmp = cur.next cur.next = pre return reverse(cur,tmp) return reverse(None,head)","link":"/2021/12/28/ReverseLinkedList/"},{"title":"Repeated Substring Pattern(1)","text":"TEST YOURSELFGiven a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. Example 1: Input: s = &quot;abab&quot; Output: true Explanation: It is the substring &quot;ab&quot; twice. Example 2: Input: s = &quot;aba&quot; Output: false HINTThe violent solution is a for loop to get the termination position of the substring, and then to determine whether the substring can be repeated to form a string, nested in another for loop, so it is O(n^2) time complexity. Here is an Better solution: Move Matching Move MatchingWhen a string s: abcabc is composed of repeated substrings within it, then the structure of the string must be such that: That is, it consists of the same substring before and after it. Then since the same substring precedes and follows the same substring, using s + s.In a string thus formed, the later substring is treated as the previous string and the earlier substring as the later string, and there must still be an s formed, as in the figure: So to determine whether the string s is composed of repeated substrings, as long as two s‘ s are spliced together and there is still an s in it, it means that s is composed of repeated substrings. Of course, when we determine whether an s appears in the s + s spliced string, we shave off the first and last characters of s + s, so as to avoid searching for the original s in s + s. What we want to search for is the s spliced out in the middle. &amp;C++ class Solution { public: bool repeatedSubstringPattern(string s) { string t = s + s; t.erase(t.begin()); t.erase(t.end() - 1); // remove head and tail if (t.find(s) != std::string::npos) return true; // r return false; } };","link":"/2022/02/28/RepeatedSubstringPattern(1)/"},{"title":"Linked List Cycle","text":"Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1,2], pos = 0 Output: tail connects to node index 0 Explanation: There is a cycle in the linked list, where tail connects to the first node. HINTThere are two main breakthrough points. Determining whether there is a ring in this linked list If there is a ring, how to find the entrance to the ring 1. Determining whether there is a ring in this linked list We can use the fast and slow pointer method to define fast and slow pointers respectively, starting from the head node, the fast pointer moves two nodes at a time, the slow pointer moves one node at a time, if the fast and slow pointers meet on the way, it means that the list has a ring. Why does the fast pointer move two nodes and the slow pointer move one node and if there is a ring, they must meet inside the ring, instead of always being staggered? First of all, the fast pointer must enter the ring first. If the fast pointer and the slow pointer meet, they must meet in the ring, there is no doubt about that. So let’s see, why must the fast pointer and the slow pointer meet? We can draw a ring and have the fast pointer start to catch up with the slow pointer at any one of the nodes. We will find that this is what happens in the end, as follows: fast and slow each take one more step, and fast and slow meet This is because fast takes two steps and slow takes one step. In fact, compared to slow, fast is approaching slow node by node, so fast must be able to overlap with slow. 2. If there is a ring, how to find the entrance to the ringAssume that the number of nodes from the head node to the ring entry node is x. The number of nodes from the ring entry node to the node where the fast pointer meets the slow pointer is y. The number of nodes from the meeting node to the ring entry node is z. As shown in the figure. Then when the fast pointer and slow pointer meet: the number of nodes walked by the slow pointer is: x + y, the number of nodes walked by the fast pointer is: x + y + n (y + z), n is the number of n turns in the ring before the fast pointer meets the slow pointer, and (y + z) is the number of nodes in a turn A. Since the fast pointer takes two nodes in one step and the slow pointer takes one node in one step, the number of nodes taken by the fast pointer = the number of nodes taken by the slow pointer * 2: (x + y) * 2 = x + y + n (y + z) eliminating one (x + y) on both sides: x + y = n (y + z) Since the entrance to the ring is to be found, then x is required because x represents the distance from the head node to the entrance node of the ring. So put x alone on the left: x = n (y + z) - y , Then from n(y + z), we can put a (y + z), and after sorting out the formula, we have the following formula: x = (n - 1) (y + z) + z. Note that n must be larger than or equal to 1 here, because the fast pointer must move at least one more turn to meet the slow pointer. What does this formula show? where n is 1. This means that the fast pointer encounters the slow pointer after one turn in the loop. When n is 1, the formula resolves to x = z This means that one pointer from the head node and one pointer from the meeting node, both of which go one node at a time, will be the node at the entrance to the ring when they meet. This means that at the meeting node, a pointer index1 is defined, and at the head node, a pointer index2 is defined. Let index1 and index2 move simultaneously, one node at a time, so that where they meet is the node at the entrance to the ring. where n is larger than 1, the fast pointer turns n times in the ring before encountering the slow pointer. In fact, the effect is the same as when n is 1. You can find the entrance node of the ring by this method, except that the index1 pointer takes an extra (n-1) turns in the ring and then meets index2, which is still the entrance node of the ring &amp;C++/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while(fast != NULL &amp;&amp; fast-&gt;next != NULL) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; // exsit a ring if (slow == fast) { ListNode* index1 = fast; ListNode* index2 = head; while (index1 != index2) { index1 = index1-&gt;next; index2 = index2-&gt;next; } return index2; // return the entrance of ring } } return NULL; } }; &amp;Javapublic class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) {// exsit a ring ListNode index1 = fast; ListNode index2 = head; // the encounter nodeis the entrance of ring while (index1 != index2) { index1 = index1.next; index2 = index2.next; } return index1; } } return null; } }","link":"/2022/01/11/LinkedListCycle/"},{"title":"Reverse String","text":"TEST YOURSELFWrite a function that reverses a string. The input string is given as an array of characters s. You must do this by modifying the input array in-place with O(1) extra memory. Example 1: Input: s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;] Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] Example 2: Input: s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;] Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] HINTIn inverting a linked list, the double pointer method is used. Inverting strings is still done using the double pointer method, except that it is actually simpler to invert strings than list. Since strings are also arrays, the elements are distributed continuously in memory, which makes the difference between inverting a chain table and inverting a string. For strings, we define two pointers (or index subscripts), one from the front of the string and one from the back of the string, and both pointers move towards the middle at the same time and swap elements. Using the string hello as an example, the procedure is as follows: &amp;C++void reverseString(vector&lt;char&gt;&amp; s) { for (int i = 0, j = s.size() - 1; i &lt; s.size()/2; i++, j--) { swap(s[i],s[j]); } } &amp;Javaclass Solution { public void reverseString(char[] s) { int l = 0; int r = s.length - 1; while (l &lt; r) { s[l] ^= s[r]; s[r] ^= s[l]; s[l] ^= s[r]; l++; # r--; } } } &amp;Python class Solution: def reverseString(self, s: List[str]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify s in-place instead. &quot;&quot;&quot; left, right = 0, len(s) - 1 while left &lt; right: s[left], s[right] = s[right], s[left] left += 1 right -= 1","link":"/2022/01/30/ReverseString/"},{"title":"Recursive Traversal of Binary Tree","text":"Three elements of the recursive algorithm： Determine the parameters and return value of the recursive function: Determine which parameters need to be handled during the recursion process, then add this parameter to the recursive function, and also define what the return value of each recursion is and thus determine the return type of the recursive function. Determine the termination conditions: After writing a recursive algorithm, when running it, we will often encounter a stack overflow error, that is, we have not written the termination conditions or the termination conditions are not written correctly. The logic for determining a single level of recursion: Determine the information that needs to be processed at each level of recursion. Here too, the call itself is repeated to implement the recursion process. Example:The following is an example of a preorder traversal. Determine the parameters of the recursive function and return value: because to print out the value of the node of the preorder traversal, so the parameters need to be passed in the vector in the value of the node put, in addition to this point will not need to deal with what data is also not required to have a return value, so the recursive function return type is void: 1void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) Determine the termination conditions: in the process of recursion, how is the recursion is considered to end it, of course, the current traversal of the node is empty, then this layer of recursion is going to end, so if the current traversal of this node is empty, it is a direct return: 1if (cur == NULL) return; Determine the logic of the single-level recursion: preorder traversal is the middle-left-right order, so the logic in the single-level recursion, is to first take the value of the node: 123vec.push_back(cur-&gt;val); // intraversal(cur-&gt;left, vec); //lefttraversal(cur-&gt;right, vec); // right Pre-Order: (Visit the parent node first, then the left and right nodes in turn) 1234567891011121314class Solution {public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; vec.push_back(cur-&gt;val); // parent traversal(cur-&gt;left, vec); // left traversal(cur-&gt;right, vec); // right } vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; traversal(root, result); return result; }}; In-Order：(Visit the left node first, then the parent and right nodes in turn) 123456void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; traversal(cur-&gt;left, vec); // left vec.push_back(cur-&gt;val); // parent traversal(cur-&gt;right, vec); // right} Post-Order：(Visit the left node first, then the right and parent nodes in turn) 123456void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; traversal(cur-&gt;left, vec); // left traversal(cur-&gt;right, vec); // right vec.push_back(cur-&gt;val); // parent} &amp;Java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Pre-Order-Recursionclass Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); preorder(root, result); return result; } public void preorder(TreeNode root, List&lt;Integer&gt; result) { if (root == null) { return; } result.add(root.val); preorder(root.left, result); preorder(root.right, result); }}// In-Order-Recursionclass Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); inorder(root, res); return res; } void inorder(TreeNode root, List&lt;Integer&gt; list) { if (root == null) { return; } inorder(root.left, list); list.add(root.val); // inorder(root.right, list); }}// Post-Order-Recursionclass Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); postorder(root, res); return res; } void postorder(TreeNode root, List&lt;Integer&gt; list) { if (root == null) { return; } postorder(root.left, list); postorder(root.right, list); list.add(root.val); // }} &amp;Python 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 # Pre-Order-Recursionclass Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: # save result result = [] def traversal(root: TreeNode): if root == None: return result.append(root.val) # parent traversal(root.left) # left traversal(root.right) # right traversal(root) return result# In-Order-Recursionclass Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: result = [] def traversal(root: TreeNode): if root == None: return traversal(root.left) # left result.append(root.val) # parent traversal(root.right) # right traversal(root) return result# Post-Order-Recursionclass Solution: def postorderTraversal(self, root: TreeNode) -&gt; List[int]: result = [] def traversal(root: TreeNode): if root == None: return traversal(root.left) # left traversal(root.right) # right result.append(root.val) # parent traversal(root) return result","link":"/2022/04/12/RecursiveTraversalofBinaryTree/"},{"title":"Swap Nodes in Pairs","text":"Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.) 1234Example 1:Input: head = [1,2,3,4]Output: [2,1,4,3] 1234Example 2:Input: head = []Output: [] HINTWe can draw a diagram to avoid confusion Initially, cur points to the dummy head node, and then the following three steps are performed. After the operation, the linked list looks like this. It might be a little more intuitive to look at this: &amp;C++1234567891011121314151617181920class Solution {public: ListNode* swapPairs(ListNode* head) { ListNode* dummyHead = new ListNode(0); // set a dummy node dummyHead-&gt;next = head; // let dummy node point to head so t hat we can operate deletion ListNode* cur = dummyHead; while(cur-&gt;next != nullptr &amp;&amp; cur-&gt;next-&gt;next != nullptr) { ListNode* tmp = cur-&gt;next; // record temp node ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next; //record temp node cur-&gt;next = cur-&gt;next-&gt;next; // Step1 cur-&gt;next-&gt;next = tmp; // Step2 cur-&gt;next-&gt;next-&gt;next = tmp1; // Step3 cur = cur-&gt;next-&gt;next; // cur node moves 2 places, which prepare to next change operation } return dummyHead-&gt;next; }}; Time Complexity: O(n) Space Complexity: O(1) &amp;Java1234567891011121314151617// Resursionclass Solution { public ListNode swapPairs(ListNode head) { // base case if(head == null || head.next == null) return head; // get next node of this node ListNode next = head.next; // recursion ListNode newNode = swapPairs(next.next); // change operation next.next = head; head.next = newNode; return next; }} 12345678910111213141516171819// Dummy nodeclass Solution { public ListNode swapPairs(ListNode head) { ListNode dummyNode = new ListNode(0); dummyNode.next = head; ListNode prev = dummyNode; while (prev.next != null &amp;&amp; prev.next.next != null) { ListNode temp = head.next.next; // temp next node prev.next = head.next; // let next of prev change to next of head head.next.next = head; // let next of head.next(prev.next) points to head head.next = temp; // let temp of head =temp prev = head; // move forward 1 place head = head.next; // move forward 1 place } return dummyNode.next; }}","link":"/2021/12/28/SwapNodesinPairs/"},{"title":"TEST","text":"###TEST1111111112222222222333333333333","link":"/2023/08/15/Test/"}],"tags":[{"name":"BackTracking","slug":"BackTracking","link":"/tags/BackTracking/"},{"name":"Combination","slug":"Combination","link":"/tags/Combination/"},{"name":"Resursion","slug":"Resursion","link":"/tags/Resursion/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/tags/C-C/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"LinkedList","slug":"LinkedList","link":"/tags/LinkedList/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"BinaryTree","slug":"BinaryTree","link":"/tags/BinaryTree/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"loop invariant","slug":"loop-invariant","link":"/tags/loop-invariant/"},{"name":"BinarySearchTree","slug":"BinarySearchTree","link":"/tags/BinarySearchTree/"},{"name":"Iteration","slug":"Iteration","link":"/tags/Iteration/"},{"name":"Pruning","slug":"Pruning","link":"/tags/Pruning/"},{"name":"TraversalOfBinaryTree","slug":"TraversalOfBinaryTree","link":"/tags/TraversalOfBinaryTree/"},{"name":"Linkedlist","slug":"Linkedlist","link":"/tags/Linkedlist/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"DoublePointers","slug":"DoublePointers","link":"/tags/DoublePointers/"},{"name":"Optimazation","slug":"Optimazation","link":"/tags/Optimazation/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"DeepLearning","slug":"DeepLearning","link":"/categories/DeepLearning/"}],"pages":[{"title":"Welcome to Jasmine&#39;blog","text":"This is my personal website and I will share relevant notes of Computer programming and Math.","link":"/About/index.html"}]}